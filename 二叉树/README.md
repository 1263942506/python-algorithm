## 套路

第一步： 分析可能性
第二步： 分析支撑可能性，需要返回的信息是什么？


## 1. 二叉树的前序遍历

- 来源： leetcode 144
- 迭代：使用栈来完成,我们先将根节点放入栈中,然后将其弹出,依次将该弹出的节点的右节点,和左节点,**注意顺序,**是右,左,为什么?因为栈是先入后出的,我们要先输出右节点,所以让它先进栈.

## 2. 二叉树的中序遍历

- 来源： leetcode 94

## 3. 二叉树的后序遍历

- 来源： leetcode 145

## 4. 二叉树的层序遍历

- 来源： leetcode 102

## 5. 不同的二叉搜索树

- 来源： leetcode 96

- 思路： dp 问题
> - dp[i]:  i个节点组成的二叉树个数
> - dp[i] = dp[i-1] * dp[0] + ... + dp[i-j][j-1] + ... + dp[0][i-1]

## 6. 从前序与中序遍历构造二叉树

- 来源： leetcode 105
- 思路： 需要注意划分的边界

## 7. 课程表

- 来源： leetcode 207

- 思路： 找图中是否有环，N 为顶点个数，E为边个数
  > - 深度优先遍历： 时间复杂度 O(N + E), 
  > - 广度优先遍历：时间复杂度 O(N + E)

## 8. 二叉搜索树

- 来源： leetcode 98


## 9. 最大 BST 子树

- 来源： leetcode 333

分析：为了获得以某节点为根节点的的搜索二叉子树，我需要以下信息：
  > 1. 左树上搜索二叉子树的大小
  > 2. 右树上搜索二叉子树的大小
  > 3.  左树其搜索二叉子树的头部
  > 4. 右树其搜索二叉子树的头部
  > 5. 左树上的最大值
  > 6. 右树上的最小值

那么，汇总来看，递归需要返回： 
> - 树的搜索二叉子树的大小， 
> - 树的搜索二叉子树的头部， 
> - 树的最大值与最小值。


## 10. 完全二叉树

- 来源： leetcode 958

- 思路： 采用层序遍历的思路做
  > - 当前节点有右节点但是没有左节点 ，则返回 False
  > - 当前节点没有右节点，则后续的所有节点如果不是叶子节点，则返回False

## 11. 平衡二叉树

- 来源： leetcode 110

## 12.  二叉树的直径

- 来源： leetcode 543

### 1. 可能性分析

- 最大长度来自左子树中的最大长度
- 最大长度来自右子树中的最大长度
- 最大长度为 左子树深度 + 右子树深度 

### 2. 分析要返回什么信息

- 树中的最大距离
- 树的深度

## 13. 员工的活跃问题

- 来源： POJ 2342

https://blog.csdn.net/zxzxzx0119/article/details/81780087


## 14. 完全二叉树节点个数

- 来源： leetcode 222


## 15. 从二叉搜索树到更大和树

- 来源： leetcode 1038
- 思路：中序遍历： 右 -> 根 -> 左


## 16. 二叉树最大宽度

- 来源： leetcode 662
- 思路：层序遍历 + 记录首末坐标

## 17. 对称二叉树

- 来源： leetcode 101
- 思路： 递归

## 18. 二叉树的右视图

- 来源： leetcode 199
- 思路：层序遍历，保存每层最后一个节点的值

## 19. 完全二叉树的节点个数

- 来源： leetcode 222
- 思路：利用完全二叉树的性质，对于高度为 h 的满二叉树， 其节点个数为 $2^h - 1$
  - 判断左右子树是否都为满二叉树
  - 若都为，则返回 $2^h-1$
  - 若不都为，则分别递归求左，右子树的节点个数