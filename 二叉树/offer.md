
# 第二章
---


## 1. 重建二叉树

- 来源： **offer 7**
- 题目： **输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树并返回。**
- 举例： 前序遍历： [1, 2, 4, 7, 3, 5, 6, 8]; 中序遍历：[4, 7, 2, 1, 5, 3, 8, 6]
- 思路： 采用递归的思想来做，与画树的思路一致，注意pre 与 vin的长度一致是一样的，重点就在于pre与vin的划分。

- 单元测试
> - 普通二叉树： 完全二叉树，非完全二叉树
> - 特殊二叉树： 所有结点都没有右孩子； 所有结点都没有左孩子； 只有一个结点
> - 特殊输入： 为空， 前序与后序不匹配

## 2. 二叉树的下一个结点

- 来源： offer 8
- 题目： **给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。**

- 思路： 
  > - 如果一个结点有右子树，则它的下一个结点就是它的右子树中的最左子结点； 
  > - 如果没有右子树，且其为其父节点的左子结点， 则它的下一个结点就是它的父结点
  > - 如果没有右子树， 且它为它父节点的右子结点， 则我们需要沿着指向父节点的指针一直向上遍历，直到找到一个它是该父节点的左子结点。此时，该父节点就是我们要找的下一个结点。

- 单元测试
> - 普通二叉树： 完全二叉树； 不完全二叉树
> - 特殊二叉树： 所有结点都没有右孩子的二叉树； 所有结点都没有左孩子的二叉树； 只有一个结点的二叉树； 二叉树的根节点指针为nullptr
> - 不同位置的结点的下一个结点： 下一个结点为当前结点的右子结点， 右子树的最左子结点， 父结点，跨层的父结点； 当前结点没有下一个结点


## 第三章

### 1. 树的子结构

- 来源： **offer 26**
- 题目： 输入两个二叉树 A 和 B， 判断 B 是不是 A 的子结构。

- 测试用例：
> - 功能测试： A 与 B 都是普通的二叉树； B 是/不是 A 的子结构
> - 特殊输入测试： 两颗二叉树的一个或两个根节点为None； 二叉树的所有节点都没有左子树或右子树


## 第四章

### 1. 二叉树的镜像

- 来源： offer 27
- 题目：输入一棵二叉树，该函数输入它的镜像。
- 思路： 先交换当前节点的左右子节点， 然后递归交换左右子节点。
- 测试用例：
  > - 功能测试： 普通二叉树； 二叉树的所有节点都没有左子树或右子树； 只有一个节点的二叉树
  > - 特殊输入测试： 根节点为 None

### 2. 对称的二叉树

- 来源：**offer 28**
- 问题： 请实现一个函数，用来判断二叉树是不是对称的。（如果一棵二叉树跟他的镜像一样，那么它就是对称的）
- 测试用例：
  > - 功能测试：对称的二叉树； 因结构不对称的二叉树，结构对称但节点值不对称的二叉树
  > - 特殊输入测试： None； 只有1个节点； 所有节点值都相同的二叉树


## 第四章

### 1. 从上到下打印二叉树

#### 1. 不分行从上到下打印二叉树

- 来源： offer 32
- 题目： 不分行从上到下打印二叉树
- 思路：本质上是层序遍历

### 2. 分行从上到下打印二叉树

- 来源： offer 32
- 题目：**从上到下按层打印二叉树， 同一层的节点按从左到右的顺序打印，每一层打印一行。**
- 思路： 每次完成一层的输出


- 测试用例
> - 功能测试：完全二叉树； 所有节点只有左子树的二叉树； 所有节点只有右子树的二叉树
> - 特殊输入测试：二叉树根节点为 nullptr； 只有1个节点的二叉树

### 3. 之字形打印二叉树

- 来源： offer 32
- 题目： 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印， 第二行按照从右到左的顺序打印。
- 思路： 设置一个 left_to_right 标志

- 测试用例：
  > - 功能测试：完全二叉树； 所有节点只有左子树的二叉树； 所有节点只有右子树的二叉树
  > - 特殊输入测试：二叉树根节点为 None； 只有1个节点的二叉树

### 4. 二叉树的后序遍历序列

- 来源：offer 33
- 题目：输入一个整数数组，判断该数组是不是某**二叉搜索树**的后序遍历结果。 如果是，返回 True， 不是，返回False。
- 思路： 分析二叉搜索树的后序遍历的特性， 其左子树 < 根 < 右子树，且最后一个元素为根，

- 测试用例：
  > - 功能测试： 输入的后序遍历序列对应一棵二叉树（完全二叉树，所有节点都没有左/右子树的二叉树； 只有1个节点的二叉树； 输入的后序遍历序列没有对应一棵二叉树
  > 特殊输入测试： 输入为 None


### 5. 二叉树中和为某一值的路径

- 来源： offer 34
- 题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。

- 思路： 回溯法
- 坑： 注意回溯法中子数组需要复制
- 测试用例：
  > - 功能测试： 二叉树中有一条，多条符合要求的路径； 二叉树中没有符合要求的路径
  > - 特殊输入测试： 输入指针为 None


### 6. 二叉搜索树转化为双向链表

- 来源：**offer 36**
- 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
- 分析：搜索二叉树中，左子节点的总是小于父节点的值。右子节点的值总是大于父节点的值，因此，在二叉搜索树转化为排序双向链表时， 原先指向左子节点的指针调整为链表中指向前一个节点的指针， 原先指向右子节点的指针调整为链表中指向后一个节点的指针。
- 思路： 先分别将左，右子树都转化为排序双向链表，然后再和根节点连接起来。



# 第六章
---

## 1. 二叉搜索树的第k大节点 -- 

- 来源： 剑指offer 53
- 题目： **给定一个二叉排序树，请找出其中第k大的节点。** 

- 思路 ： 一次中序遍历得到二叉搜索树的一个有序数组arr， 返回arr[k-1] 即可
- 坑： 一些边界条件坑的很惨

- 测试用例：
> - 功能测试： 不同形态的二叉搜索树
> - 边界值测试： 输入k = 1，0，二叉搜索树节点数， 二叉搜索树节点数+1
> - 特殊输入测试：  根节点为 nullptr


## 2. 二叉树的深度

- 来源： 剑指offer 55

### 1. 二叉树的深度

- 题目： **输入一颗二叉树的根节点， 求该二叉树的深度。 从根节点到叶节点依次经过的节点（含根，叶）形成树的一条路径， 最长路径的长度为树的深度。**

- 思路2： 
> - 如果一棵树只有一个节点， 则它的深度为1； 
> - 如果根节点只有左子树而没有右子树， 那么树的深度 = 左子树深度+1； 
> - 如果根节点只有右子树而没有左子树， 则深度 = 右子树深度+1； 
> - 如果左，右子树都有， 则树的深度 =  左，右子树深度较大值 + 1

- 测试用例：
> - 功能测试： 输入普通的二叉树； 二叉树中所有节点都没有左/右子树
> - 特殊输入测试： 二叉树中只有一个节点； 二叉树的头节点为 nullptr 指针

- 坑： 思路比较绕，需要理清楚。

### 2. 平衡二叉树

- 问题：输入一颗二叉树的根节点， 判断该树是不是平衡二叉树。 如果某二叉树中任意节点的左，右子树的深度相差不超过1， 则它就是一颗平衡二叉树。

- 思路2： 采用后序遍历的方式遍历二叉树的每个节点， 那么在遍历到一个节点之前我们就已经遍历了其左，右子树。 只要在遍历每个节点的时候记录它的深度，我们就可以一边遍历，一边判断每个节点是不是平衡的。

- 测试用例：
  > - 功能测试： 平衡的二叉树； 不平衡的二叉树； 二叉树中所有节点都没有左/右子树
  > - 特殊输入测试： 二叉树中只有一个节点； 二叉树的头节点为 nullptr 


