
## 例1： 时间复杂度

- 问题： 一个有序数组A， 另一个无序数组B， 请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M
- 算法1： 对于B中每一个数，都在A中通过遍历的方式查找  -- O(N*M)
- 算法2： 对于数组B中的每一个数，都在A中通过二分的方式查找  -- O(M * logN)
- 算法2： 先把数组B排序，然后用类似外排的方式打印所有在A中出现的数 -- O(M*logM) + O(N + M);
  > - b > a : a++
  > - b < a: print(b), b++
  > - b == a: b++




## 例2： 对数器

解决case不可控的问题

### 好处

- 可以不用依赖OJ，直接验证
- 小样本通过，但大样本失败时，对数器可以帮你
- 可以验证贪心策略

### 对数器

1. 随机样本产生器  -- generate_sample()
2. 准备一个绝对正确但复杂度不好的方法B（可能过不了OJ) -- B()
3. 比对方法， 验证B方法结果与你的方法是否相等 is_euqal()
4. 大样本测试，如果一个样本使得比对出错，打印样本分析是哪个方法出错
5. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确

**提前准备好模板：数组等数据结构**


## 例6： 递归

任何递归行为都可以改成非递归。

估计递归复杂度的通式：
$$
T(N) = aT(\frac{N}{b}) + O(N^d)
$$

> - N： 原样本量
> - N/b: 子过程的样本量
> - a： 子过程发生的次数
> - d： 除去调用子过程之外，剩下的代价

1. if $log_b a > d$, 则复杂度为 $O(N^log_b a)$
2. if $log_b a = d$, 则复杂度为 $O(N^d*logN)$
3. if $log_b a < d$, 则复杂度为 $O(N^d)$  


## 例8： 小和问题与逆序对问题

### 1. 小和问题

- 问题：在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和。求一个数组的小和。
- 思路： 利用归并排序的思想，在合并的时候计算小和

### 2. 逆序对问题

在一个数组中,左边的数如果比右边的数大,则折两个数构成一个逆序对,请打印所有逆序对。
