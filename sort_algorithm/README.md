
## 性能分析一览

算法 |  最好时间复杂度 |  平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性
--- | --- | --- | --- | --- |--- 
直接插入排序 | $O(n)$  | $O(n^2)$ | $O(n^2)$ |$O(1)$ | 稳定
冒泡排序 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定
简单选择排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | 不稳定
shell 排序 |  |  |  | $O(1)$ | 不稳定
快速排序 | $O(nlog_2n)$ |  $O(nlog_2n)$  | $O(n^2)$ | $O(nlog_2n)$ | 不稳定
堆排序 | $O(nlog_2n)$ |  $O(nlog_2n)$  | $O(nlog_2n)$ | $O(1)$ | 不稳定
2路归并排序 |  $O(nlog_2n)$ |  $O(nlog_2n)$  | $O(nlog_2n)$ | $O(n)$ | 稳定
基数排序 | $O(d(n+r))$ |  $O(d(n+r))$  | $O(d(n+r))$ | $O(r )$ | 稳定

## 比较与移动

内部排序算法主要进行两种操作： 比较和移动，但并不是所有算法都要基于比较操作（如基数排序）

算法 | 最好比较次数 | 最坏比较次数 | 最好移动次数 | 最坏移动次数 
--- | --- | --- | --- | ---



## 基本概念

### 什么是部分有序
-  数组中每个元素距离它的最终位置都不远
-  一个有序的大数组接一个小数组
-  数组中只有几个元素的位置不正确

### 算法稳定性
算法稳定性指的是算法在排序过后其元素相对位置不发生变化。 注意：稳定性并不能衡量一个算法的优劣，而主要是对算法的性质进行描述。

### 内部排序与外部排序

-  内部排序： 在排序期间元素全部存放在内存中的排序
-  外部排序： 排序期间元素无法同时存放在内存中，必须在排序过程中根据要求不断在内，外存之间移动的排序。


## 1. 选择排序
> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。

- 运行时间和输入无关: 有序的数组与无序的数组所需的时间一样长
- 数据移动是最少的： 只需要 N 次交换, 且交换次数与数组大小是线性关系
- 在排序到第i次时， 前 i-1 个元素是有序的， 且都是最终的位置

名称              |     最好情况           | 平均情况           | 最坏情况
---               |    ---                | ---               | ---
比较次数           |       N(N-1)/2        |       N(N-1)/2    | N(N-1)/2
交换次数           |         N             |          N       |   N


## 2. 插入排序
** 适合部分有序的数组与小规模数组 **

> 从无序数组中抽取一个元素，插入到已经排序好的数组的适当位置， 如果插入位置为i， 则 i+1 到 n 的所有元素都要向右移动一位。

- 最坏情况下，数组是逆序的； 最好情况下， 数组是有序的
- 运行时间与输入数据有关， 对于有序数组进行排序回避随机数组或逆序数组要快得多
- 在第i次时， 前i-1个元素是有序的，但不是最终的位置
- 插入排序需要的交换操作和数组中倒置的数量相同
- 比较的总次数是交换次数加上一个额外的项， 该项为N 减去被插入的元素正好是已知的最小
元素的次数。在最坏情况下（逆序数组），这一项相对于总数可以忽略不计；在最好情况下（数
组已经有序），这一项等于 N -1。
- 插入排序需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一

名称               |     最好情况            | 平均情况           | 最坏情况
---                | ---                | ---               | ---
比较次数            |       N-1          |    $N^2/4$     | $N^2/2$
交换次数            |       0            |    $N^2/4$     | $N^2/2$

## 3. 希尔排序
> 希尔排序是对插入排序的改进。
思想： 使得数组中任意间隔为h的元素都是有序的（称为h有序数组）， 然后依次减小h的大小，最终获得一个有序序列



## 4. 归并排序


## 5. 快速排序


## 6. 堆排序

堆是一个完全二叉树， 树的根节点为A[1]，这样使得给定一个下标i，我们很容易计算得到它的父节点，左孩子，右孩子节点的下标：

$$
父节点 = i/2 (向下取整) \\
左孩子 = 2i  \\
右孩子 = 2i + 1
$$

二叉堆可分为两种：最大堆与最小堆。堆排序算法中，我们使用最大堆，最小堆通常用于构造优先队列。
- 最大堆中要满足：父节点比子节点大。
- 最小堆中满足： 父节点比子节点要小。

堆排序可分为两个阶段：
- 堆构造： 将原始数据重新组织安排进一个堆中。
- 下沉排序：从堆中按递减顺序去除所有元素并得到排序结果。
