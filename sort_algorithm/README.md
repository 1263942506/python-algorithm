
## 性能分析一览

算法名                     | 时间复杂度                 | 空间复杂度
---                        | ---                        | ---    
选择排序                   |  $O(n^2)$                  |   O(1)  
插入排序                   |  $O(n) \to O(n^2)$         |  o(1)    
希尔排序                   |                            |      
归并排序                   |                            |      
快速排序                   |                            |       
堆排序                     |     O(nlogn)                       |     o(1)


## 各种排序算法分析

### 什么是部分有序
-  数组中每个元素距离它的最终位置都不远
-  一个有序的大数组接一个小数组
-  数组中只有几个元素的位置不正确


## 1. 选择排序
> 首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。

- 运行时间和输入无关: 有序的数组与无序的数组所需的时间一样长
- 数据移动是最少的： 只需要 N 次交换, 且交换次数与数组大小是线性关系
- 在排序到第i次时， 前 i-1 个元素是有序的， 且都是最终的位置

名称              |     最好情况           | 平均情况           | 最坏情况
---               |    ---                | ---               | ---
比较次数           |       N(N-1)/2        |       N(N-1)/2    | N(N-1)/2
交换次数           |         N             |          N       |   N


## 2. 插入排序
** 适合部分有序的数组与小规模数组 **

> 从无序数组中抽取一个元素，插入到已经排序好的数组的适当位置， 如果插入位置为i， 则 i+1 到 n 的所有元素都要向右移动一位。

- 最坏情况下，数组是逆序的； 最好情况下， 数组是有序的
- 运行时间与输入数据有关， 对于有序数组进行排序回避随机数组或逆序数组要快得多
- 在第i次时， 前i-1个元素是有序的，但不是最终的位置
- 插入排序需要的交换操作和数组中倒置的数量相同
- 比较的总次数是交换次数加上一个额外的项， 该项为N 减去被插入的元素正好是已知的最小
元素的次数。在最坏情况下（逆序数组），这一项相对于总数可以忽略不计；在最好情况下（数
组已经有序），这一项等于 N -1。
- 插入排序需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一

名称               |     最好情况            | 平均情况           | 最坏情况
---                | ---                | ---               | ---
比较次数            |       N-1          |    $N^2/4$     | $N^2/2$
交换次数            |       0            |    $N^2/4$     | $N^2/2$

## 3. 希尔排序
> 希尔排序是对插入排序的改进。
思想： 使得数组中任意间隔为h的元素都是有序的（称为h有序数组）， 然后依次减小h的大小，最终获得一个有序序列



## 4. 归并排序


## 5. 快速排序


## 6. 堆排序

堆是一个完全二叉树， 树的根节点为A[1]，这样使得给定一个下标i，我们很容易计算得到它的父节点，左孩子，右孩子节点的下标：

$$
父节点 = i/2 (向下取整) \\
左孩子 = 2i  \\
右孩子 = 2i + 1
$$

二叉堆可分为两种：最大堆与最小堆。堆排序算法中，我们使用最大堆，最小堆通常用于构造优先队列。
- 最大堆中要满足：父节点比子节点大。
- 最小堆中满足： 父节点比子节点要小。

堆排序可分为两个阶段：
- 堆构造： 将原始数据重新组织安排进一个堆中。
- 下沉排序：从堆中按递减顺序去除所有元素并得到排序结果。
