
## 性能分析一览

算法 |  最好时间复杂度 |  平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 稳定性
--- | --- | --- | --- | --- |--- 
直接插入排序 | $O(n)$  | $O(n^2)$ | $O(n^2)$ |$O(1)$ | 稳定
冒泡排序 | $O(n)$ | $O(n^2)$ | $O(n^2)$ | $O(1)$ | 稳定
选择排序 | $O(n^2)$ | $O(n^2)$ | $O(n^2)$ | 不稳定
shell 排序 |  | $O(n^{1.3}$) | $O(n^2)$ | $O(1)$ | 不稳定
快速排序 | $O(nlog_2n)$ |  $O(nlog_2n)$  | $O(n^2)$ | $O(nlog_2n) -- O(n)$ | 不稳定
堆排序 | $O(nlog_2n)$ |  $O(nlog_2n)$  | $O(nlog_2n)$ | $O(1)$ | 不稳定
2路归并排序 |  $O(nlog_2n)$ |  $O(nlog_2n)$  | $O(nlog_2n)$ | $O(n)$ | 稳定
基数排序 | $O(d(n+r))$ |  $O(d(n+r))$  | $O(d(n+r))$ | $O(r )$ | 稳定


## 比较与移动

内部排序算法主要进行两种操作： 比较和移动，但并不是所有算法都要基于比较操作（如基数排序）

算法 | 最好比较次数 | 平均比较次数 | 最坏比较次数 | 最好移动次数 | 平均移动次数| 最坏移动次数 
--- | --- | --- | --- | ---
插入排序 | n | $\frac{n^2}{4}$   |$\sum_{i=1}^n i$ | 0 |$\frac{n^2}{4}$ | $\sum_{i=2}^n (i+1)
冒泡排序 | n-1 | $\sum_{i=1}^{n-1} = \frac{n(n-1)}{2}$ | 0 | $\sum_{i=1}^{n-1} 2(n-i) = \frac{3n(n-1)}{2}$
选择排序 | $\frac{n(n-1)}{2}$ | $\frac{n(n-1)}{2}$ | 0 |  n



## 基本概念

### 算法稳定性

算法稳定性指的是算法在排序过后其元素相对位置不发生变化。 注意：稳定性并不能衡量一个算法的优劣，而主要是对算法的性质进行描述。
稳定性的意义： 在有多个条目需要进行排序时，可能想要保存原有的排序相对位置，此时就需要采用稳定的排序算法。

### 内部排序与外部排序

-  内部排序： 在排序期间元素全部存放在内存中的排序
-  外部排序： 排序期间元素无法同时存放在内存中，必须在排序过程中根据要求不断在内，外存之间移动的排序。

---

## 插入排序

主要思想在于： 每次将一个待排序的记录，按照其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。 基于此思想可以引申出三个重要排序算法： 直接插入排序， 折半插入排序和希尔排序。 

### 1. 直接插入排序，折半插入排序

> 思想： 从无序数组中抽取一个元素，插入到已经排序好的数组的适当位置， 如果插入位置为i， 则 i+1 到 n 的所有元素都要向右移动一位。
> - 从有序的子表中找出待插入元素应该被插入的位置
> - 给插入位置腾出空间，将待插入元素复制到表中的插入位置。

- 在第i次时， 前i-1个元素是有序的，但不是最终的位置
- 最好情况： 表中元素已经有序
- 最坏情况： 表中元素逆序

### 2. 希尔排序
> - 思想： 先将待排序表分割为若干子表， 对每个子表分别进行直接插入排序，当整个表中元素已经”基本有序“时，再对全体元素进行一次直接插入排序。





---

## 1. 选择排序
> 首先，找到数组中最小的那个元素，然后，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。

- 数据移动是最少的： 只需要 N 次交换, 且交换次数与数组大小是线性关系
- 在排序到第i次时， 前 i-1 个元素是有序的， 且都是最终的位置

名称              |     最好情况           | 平均情况           | 最坏情况
---               |    ---                | ---               | ---
比较次数           |       N(N-1)/2        |       N(N-1)/2    | N(N-1)/2
交换次数           |         N             |          N       |   N


## 3. 冒泡排序

> 思想: 假设数组长为n, 从后往前(或从前往后) 两两比较相邻元素的值,若为逆序,则交换它们,直到序列比较完.

- 每一趟排序都会有一个元素放置到其最终的位置上.





## 4. 归并排序
> - 思想: 分解 -- 先将数组分解为两个或多个子数组， 然后采用归并排序对这些子数组递归排序； 合并 -- 将两个或两个以上的有序表合并成为一个新的有序表, 合并的算法可以有所变化.
> - 代码分为两部分： merge(): 将两个(或多个)有序数组组成一个有序数组， merge_sort(): 归并排序的核心。 一趟归并排序的操作是： 调用 $\frac{n}{2h}$ 次算法merge()将L[1...n] 中前后相邻且长度为h的有序段进行两两归并 ，得到前后相邻，长度为2h 的有序段，整个归并排序需要进行 $[log_2n]$ 趟

**对于N个元素进行k-路归并排序时， 排序的趟数m满足$k^m = N$， 从而有 $m = log_kN$， 又考虑到m为整数， 因此m向上取整。**



## 5. 快速排序
**快速排序是对冒泡排序的一种改进， 其思想基于分治策略**
> - 思想： 在待排序表$L[1...n]$ 中任意取一个元素 pivot 作为基准， 通过一趟排序将数组划分为独立的两部分 $L[1 ... k-1]$ 和 $L[1...k+1]$， 使得 $L[1...k-1]$ 中所有元素小于pivot， $L[k+1...n]$ 中所有元素大于或等于 pivot, 则pivot放在了其最终位置 L[k] 上。然后分别递归地对两个子表重复上述股哟成，直至每部分内只有一个元素或空为止，此时所有元素都在其最终的位置上。
> - 一点改进： 经典快排一次只将一个元素放置到其最终的位置，如果我们可以参考荷兰国旗问题，一次将与该元素相同的所有元素放到最终位置，这样节省下来常数时间。
> - 经典快排的问题： 划分可能不均匀， 这种情况很容易造成 $O(n^2)$ 
> - 随机快排： 采用随机选一个数，然后将该数与最后一个元素交换，然后再进行快排， 这是最常用的排序。
> - 空间复杂度与递归的深度有关
> - 时间复杂度与划分是否对称有关。最坏情况是基本有序或逆序的情况，此时划分极度不均匀，分别包含n-1 和 0 个元素。 

- 快排是所有内部排序中平均性能最优的排序算法
- 快排中，并不产生有序子序列，但每一趟排序后将一个元素放到其最终位置上。


## 6. 堆排序

堆是一个**完全二叉树**， 树的根节点为A[0]，这样使得给定一个下标i，我们很容易计算得到它的父节点，左孩子，右孩子节点的下标：

> - 父节点 = (i-1)/2 
> - 左孩子 = 2i + 1 
> - 右孩子 = 2i + 2


二叉堆可分为两种：最大堆与最小堆。堆排序算法中，我们使用最大堆，最小堆通常用于构造优先队列。
- 最大堆中要满足：父节点比子节点大。
- 最小堆中满足： 父节点比子节点要小。

堆排序可分为两个阶段：
- 堆构造： 将原始数据重新组织安排进一个堆中。
- 下沉排序：从堆中按递减顺序去除所有元素并得到排序结果。

### 大根堆构造


--- 

##基数排序， 桶排序， 计数排序

- 非基于比较的排序,与被排序的样本的实际数据状况很有关系,所以实际中并不经常使用
- 时间复杂度 O(N)， 额外空间复杂度O(N)
- 稳定的排序

### 基数排序


### 桶排序

### 计数排序





## 工程中的综合排序算法

1. 先判断要排序的是基础类型还是自己定义的类型， 如果是基础类型（不稳定）， 选择快排（稳定）， 如果是自己的类，选择归并排序
2. 如果数组长度很短（小于60），选择插入排序， 因为其常数项很低。


## 排序问题的补充


- 归并排序的额外空间复杂度可以变成O(1)， 但是非常难， 不需要掌握，可以搜 ”归并排序 内部缓存法“ 。
- 快速排序可以做到稳定，但是非常难，不需要掌握，可以搜 ”01 stable sort“
- 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官，面试官非良人。



