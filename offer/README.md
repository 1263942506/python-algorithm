

## 面试题1：赋值运算符函数 -- assignOperator.cc

- 题目： 如下为类型 CMyString 的声明， 请为该类型添加赋值运算

```
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);

private:
    char* m_pData;
}
```

- 定义赋值运算符函数时的要点：
> - 是否把返回值的类型声明为该类型的引用，并在该函数结束前返回实例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值，否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。






---

## 53. 在排序数组中查找数字

### 1. 数字在排序数组中出现的次数 -- occur_times

- 题目： 统计一个数字在排序数组中出现的次数。 

- 思路1： 采用二分查找找到该数字后，分别向左， 右两边扫描找到第一次出现和最后一次出现的位置，最后得到最终出现的次数。
- 思路2：直接找到第一次出现，最后一次出现的位置。
  > - 如果 arr[mid] > key, 则在[0:mid-1]位置查找
  > - 如果 arr[mid] < key, 则在 [mid+1:] 位置查找
  > - 如果 arr[mid] == key, 则判断 arr[mid] 是不是第一个key。 如果arr[mid-1] == key, 则说明第一个key 一定在 [0:mid-1] 段； 如果 arr[mid-1] != key， 则说明arr[mid]就是第一个key。

- 测试用例：
  > - 功能测试： 数组中包含要查找的数字； 数组中不包含要查找的数字； 要查找的数字在数组中出现一个或多次
  > - 边界测试： 查找数组中最大值，最小值； 数组只有一个数字
  > - 特殊输入： 数组为空

### 2. 0- n-1 中缺失的值： miss_val

- 题目： 一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0-n-1 之内。 并且每个数字都在范围0-n-1之内。 在范围0-n-1 的n 个数字中有且只有1个数字不再该数组中，请找出这个数字。

- 思路1： 用公式 n(n-1)/2 求出数字 0-n-1 的所有数字的和，记为s1； 接着求出数组中所有数字的和， 记为s2， 然后返回 s1 - s2 即可。
- 思路2： 从头到尾遍历数组， 遇到第一个 arr[i] != i 的， 输出i
- **思路3：** 采用二分查找，目的是找到第一个 arr[i] != i 的数。  如果 arr[mid] == mid ， 则需要向 [mid+1:]查找，如果 arr[mid] != mid ， 则先判断 arr[mid-1] == mid-1 ?, 如果不等于，则需要向 [:mid-1] 方向查找； 如果等于，则返回mid

- 测试用例：
  > - 功能测试： 缺失的值在数组开始， 中间， 末尾
  > - 边界测试： 数组中只有一个数字0
  > - 特殊输入测试： 空数组

### 3. 数组中数值和下标相等的元素

- 题目： 假设一个单调递增的数组里的每个元素都是整数且唯一。 请实现一个函数，找出数组中任意一个数值等于其下标的元素。 
- 举例： [-3, -1, 1, 3, 5] ， 返回3

- 思路1： 从头到尾遍历比较，如果arr[i] == i, 则返回i 
- 思路2： 采用二分查找， 如果arr[mid] > mid， 则在 arr[:mid-1]区间内查找； 如果arr[mid] == mid， 则返回mid； 如果 arr[mid] < mid， 则在 arr[mid+1:] 内查找。

- 测试用例：
  > - 功能测试： 数组中包含或不包含数值和下标相等的元素
  > - 边界值测试： 数组中只有一个数字； 数值和下标相等的元素位于数组的开头或结尾
  > - 特殊输入： 空数组





构建一个含有n个节点的环形链表， 每次在这个链表中删除第m个节点。

### 思路2：

定义方程： f(n.m)， 表示每次在n个数字 0，..., n-1 中删除第m个数字最后剩下的数字


---

## 7.1 字符串转化为整数

- 考虑边界情况： 空字符， 空指针， 正负号， 溢出，非数字字符


## 7.2 树中两个节点的最低公共祖先

