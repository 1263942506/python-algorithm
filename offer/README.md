

## 面试题1：赋值运算符函数 -- assignOperator.cc

- 题目： 如下为类型 CMyString 的声明， 请为该类型添加赋值运算

```
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);

private:
    char* m_pData;
}
```

- 定义赋值运算符函数时的要点：
> - 是否把返回值的类型声明为该类型的引用，并在该函数结束前返回实例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值，否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。


## 面试题3：数组中重复的数字 - array_duplicate

- 题目： 找出数组中重复的数字。在一个**长度为n**的数组里的所有数字都在**0到n-1**的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

- 方案1： 双重循环 ： $O(n^2)$ -- 不推荐

- 方案2： 先排序，后查找: $O(nlogn)$

- 方案3： 哈希思想: 时间--$O(n)$， 空间--$O(n)$

### 最佳方案

- 分析： 数组中的数字都在 $0 -- n-1$ 之间。如果这个数组中没有重复的数字，那么当数组排序后数字i将出现在下标为i的位置。这也意味着，如果数组中有重复的数字，那么在某些位置上就有多个数字，而有些位置可能没有数字。

- 思路1： 采用额外数组other，初始化为0， 从头到尾遍历数组, 遍历过程中判断， if 此时other[val] >= 1，则， 返回val， 否则， other_val += 1
- 思路2： 不采用额外数组， 则遍历数组时，需要判断 arr[i] 是否等于 i。 如果相等，则 i += 1； 如果不相等， arr[i], arr[arr[i]] 进行交换

### 单元测试

- 长度为n的数组中包含一个或多个重复数字
- 数组中不包含重复数字。
- 无效的输入测试用例： 空指针，长度为n的数组包含 0-n-1 之外的数字

## 面试题4： 二维数组的查找 -- array_find

- 题目： 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

- 方案1： 双重循环，顺序查找，最多加上折半

### 最佳方案

- 分析： 如果数组中的数字小于要查找的数字，则要查找的数字应该在当前数字位置的右边或下边； 如果选取的数字大于要查找的数字，那么要查找的数字应该在当前数字位置的上边或左边。

![](http://ww1.sinaimg.cn/large/006gOeiSly1g0axrjvz40j30jr0ab77i.jpg)

- 思路：首先选取数组中右上角（从左下角也可）数字。 如果该数字等于要查找的数字，则查找过程结束； 如果该数字大于要查找的数字，则剔除这个数字所在的列； 如果该数字小于要查找的数字，则剔除这个数字所在的行。


### 单元测试

- 二维数组中包含查找的数字
- 二维数组中没有查找的数字
- 特殊输入： 空指针


## 面试题5： 替换空格 -- string_space

- 题目： 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

- 思考： 一个空格字符在替换后变成'%', '2', '0' 三个字符，因此字符串会变长。

### 思路1：转化为列表

思想： 遍历整个字符串， 当遇到是空格时，将'%20'存入列表中， 否则则将该字符存入列表中，最后再将列表转化为字符串。

时间复杂度为 O(n), 空间复杂度为 O(n + 2k), k为空格的数目。


### 思路2：

在c系语言中，字符串是可变的， 因此可以采用空间复杂度，时间复杂度都较低的算法来实现。

- 思想： 首先计算出替换后的字符串长度。然后准备两个索引：index_origin, index_new； index_origin 指向原始字符串的末尾，index_new 指向替换之后的字符串的末尾。 从尾到头的用index_origin 遍历原始字符串，如果str[index_origin] != 空格， 则str[index_new] = str[index_origin]； 如果 str[index_origin] == 空格， 则分别复制 '0', '2', '%' 到str中, 直至 index_origin 遍历完毕。 


### 单元测试

- 输入的字符串包含空格
- 输入的字符串不包含空格
- 特殊输入： 字符串为nullptr指针，空字符串，只有一个空格字符，连续多个空格


## 面试题7： 重建二叉树 -- re_construct_binary_tree

- 题目： **输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树并返回。**
- 举例： 前序遍历： [1, 2, 4, 7, 3, 5, 6, 8]; 中序遍历：[4, 7, 2, 1, 5, 3, 8, 6]
- 思路： 采用递归的思想来做，与画树的思路一致，注意pre 与 vin的长度一致是一样的，重点就在于pre与vin的划分。

### 单元测试

- 普通二叉树： 完全二叉树，非完全二叉树
- 特殊二叉树： 所有结点都没有右孩子； 所有结点都没有左孩子； 只有一个结点
- 特殊输入： 为空， 前序与后序不匹配

## 面试题8： 二叉树的下一个结点

- 题目： **给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。**

- 思路： 
  > - 如果一个结点有右子树，则它的下一个结点就是它的右子树中的最左子结点； 
  > - 如果没有右子树，且其为其父节点的左子结点， 则它的下一个结点就是它的父结点
  > - 如果没有右子树， 且它为它父节点的右子结点， 则我们需要沿着指向父节点的指针一直向上遍历，直到找到一个它是该父节点的左子结点。此时，该父节点就是我们要找的下一个结点。

### 单元测试

- 普通二叉树： 完全二叉树； 不完全二叉树
- 特殊二叉树： 所有结点都没有右孩子的二叉树； 所有结点都没有左孩子的二叉树； 只有一个结点的二叉树； 二叉树的根节点指针为nullptr
- 不同位置的结点的下一个结点： 下一个结点为当前结点的右子结点， 右子树的最左子结点， 父结点，跨层的父结点； 当前结点没有下一个结点


## 面试题9： 栈与队列

### 1. 用两个栈实现一个队列
- 题目： 用两个栈来实现一个队列，完成队列的Push和Pop操作。

- 思路： 
  > - push： 直接将元素直接存入 stack1 中
  > - pop: 如果stack2为空，则将stack1 中元素压入到stack2中，再pop； 如果非空，则直接pop。

- 单元测试
> - 向空的队列中添加，删除元素
> - 向非空的队列中添加，删除元素
> - 连续删除元素直至队列为空

### 2. 用两个队列实现一个栈

- 题目：用两个队列实现栈
- 思路：data， help
> - push： 直接将元素存入data中
> - pop： 将data 中的元素依次 pop到help中，直至data中只剩下一个元素， 然后弹出该元素， data， help互换


## 面试题10： 斐波那契数列 -- fibonacci

### 题目1

输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）

$$
f(n)= \begin{cases} 0 \qquad n=0 \\ 1  \qquad n=1 \\ f(n-1) + f(n-2) \qquad n>1 \end{cases}
$$

- 思路1： 直接采用递归按照公式来做，计算量巨大，不推荐
- 思路2： 去掉重复运算，通过先计算f(2),f(3)依次计算，直至第n项


### 题目2： 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

- n=1 时， 1种跳法, 即 f(1) = 1
- n=2 时， 2种跳法, 即 f(2) = 2
- n>2 时， 第一次跳的时候有两种选择：
  > - 第一次只跳1级，则此时跳法数目 = 后面剩下n-1级的跳法数目 f(n-1)
  > - 第一次只跳2级，则此时跳法数目 = 后面剩下的 n-2 级台阶的跳法数目 f(n-2)
  因此有f(n) = f(n-1) + f(n-2)

### 题目3：变态跳台阶

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

我们可以用归纳法推出： $f(n) = f(1) + ... + f(n-1) + 1 =  2^{n-1}$

### 题目4： 矩形覆盖

我们可以用 `2*1` 的小矩形横着或者竖着覆盖更大的矩形，请问用n个 `2*1` 的小矩形五重叠的覆盖一个 `2*n` 的大矩形，总共有多少种方法。

- n =1: f(n) = 1
- n =2: f(n) = 2
- n > 2: f(n) = f(n-1) + f(n-2)

### 单元测试

- 功能测试： 输入3， 5
- 边界测试： 0,1,2
- 性能测试： 较大的数：100


## 面试题11： 旋转数组的最小数字 -- min_number_of_RotateArray

- 题目： **把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。**

### 思路 1：

找到第一个出现逆序的数字即可， 如在上例中{5,1} 是逆序的，因此最小值为1。
时间复杂度为 O(n)

### 思路2：

采用二分查找的思想来做： 定义指针位置p1:指向数组第一个元素 , p2：指向数组最后一个元素。 先找到中间元素 mid:
> - 如果 arr[mid] >= arr[p1], 则说明p1-mid 是有序的， 最小值不在该范围内： p1 = mid;  
> - 如果 arr[mid] <= arr[p2], 则说明 mid-p2是有序的， 最小值不在该范围内： p2 = mid;

最终，0-p1 表示的是前面递增数组的元素， p2- 表示后面递增数组的元素；最终，p1将指向前面递增子数组的最后一个元素， p2 将指向后面递增子数组的第一个元素， 且p2所在的位置就是最小的元素。 


### 单元测试

- 功能测试： 输入的数组是升序排序数组的一个旋转； 数组中有重复数字/没有
- 边界测试： 输入的数组是一个升序排序的数组；只包含一个数字的数组
- 特殊输入测试： nullptr指针


## 面试12：矩阵中的路径

- 问题： **请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子**。 例如 
  a b t g 
  c f c s 
  j d e h 
  这样的3 X 4 矩阵中包含一条字符串"bfce"的路径，但是矩阵中不包含"abfb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

### 思路：

采用回溯法的思想， 要注意的是：
> - 起点并不确定，因此需要对每一个起点进行回溯
> - 不能重复进入同一个格子， 因此需要维护一个判断是否访问过的矩阵，且需要注意该矩阵的处理
> - 需要注意终止条件

### 测试用例：

- 功能测试： 存在路径； 不存在路径
- 边界测试：矩阵只有一行/一列； 矩阵和路径中的所有字母都是相同的
- 特殊输入测试：矩阵为空， str为空


## 13. 机器人的运动范围

- 问题：**地上有一个m行n列的方格。 一个机器人从坐标(0,0) 的格子开始移动，它每次可以向左，右， 上，下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子， 问该机器人能够到达多少个格子？**
- 举例： k=18， 则机器人能进入方格(35, 37)， 因为3+5+3+7 = 18. 但它不能进入方格 (35,38). 因为3 + 5 + 3 + 8 = 19. 

 - 思路： 采用回溯法， 如果机器人能够进入坐标(i, j)的格子， 再判断它能否进入4个相邻的格子 (i, j-1), (i-1, j), (i, j+1), (i+1, j)

- 测试用例：
> - 功能测试： 方格为多行多列； k为正数
> - 边界值测试： 方格只有1行；方格只有1列； k 等于0
> - 特殊输入测试： k为负数

## 14. 剪绳子

- 题目： **给你一根长度为n的绳子，请把绳子剪成m段(m,n 都是整数， n>1, m>1)， 每段绳子的长度记为 k[0], k[1]，...，k[m]。 请问k[0] * ... *k [m] 可能的最大乘积是多少？**

### 思路1：动态规划

- 递归形式分析
> - 首先，定义函数f(n) 为长度为n的绳子剪成若干段各段长度乘积的最大值
> - 第一刀时， 有n-1种可能，此时， f(n) = max(f(1) * f(n-1), f(2) * f(n-2), ... f(n-(n-1)) * f(1))
   这是一个从上到下的递归公式， 此时会有大量的重复计算。

- 非递归分析：
> - 更好的办法是按照从下到上的顺序计算， 即先计算f(2), f(3)， 再得到 f(4), f(5)， 最终得到 f(n)
> - n = 2 时， 剪成长度各为1的两段，f(2) = 1
> - n = 3 时， 剪成长度为1和2的两段或者长度都为1的三段， f(3) = 2

### 思路2： 贪婪算法

如果按照如下策略剪绳子， 则得到的各个绳子的长度乘积最大：
> - n>=5时， 尽可能多剪长度为3的绳子
> - n = 4 时， 将绳子剪成长度为2的两段

### 测试用例：

- 功能测试： 绳子的初始长度大于5
- 边界测试： 绳子初始长度分别为 0， 1， 2，3， 4

## 15. 二进制中 1 的个数

- 题目： 请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。
- 举例： 9， 二进制表示为1001， 有2位为1， 因此输出2

### 思路1：

不右移n， 而是首先用 n 与1 做位运算， 判断n的最低位是不是1， 接着把1左移一位得到2， 再与n做位运算， 以此类推。

### 思路2：

将一个整数减去1， 再和原整数做与运算，会将该整数最右边的1变成0， 该整数二进制有多少个1， 就可以进行多少次这样的操作

### 测试用例：

- 正数： 边界值1， 0x7FFFFFFF
- 负数： 边界值
- 0

---

## 16. 数值的整数次方

- 题目： 实现函数 double power(double base, int exponent)， 求 base 的 exponent 次方。
- 要求： 不得使用库函数， 同时不需要考虑大数问题

### 思路1：

主要考察边界条件：
> - base = 0 exponent < 0时， 报错
> - exponent > 0, exponent < 0, exponent = 0 时 

### 思路2：

- 当 exponent 为偶数时， f(n) = f(n/2) * f(n/2)
- 当 exponent 为奇数时， f(n) = f((n-1)/2) *  f((n-1)/2) * a 

### 测试用例

将base 和exponent 分别设置为正数， 负数，0

## 17. 打印从1到最大的n位数

- 题目： 输入数字n， 按顺序打印出从1到最大的n位十进制数。
- 举例： 输入3，则打印1，... , 999
- 陷阱： n很大时的溢出问题， n <= 0 时的错误输入问题

### 思路1：

为了避免溢出问题，需要通过字符串来进行操作，在字符串上模拟数字的加法。


### 思路2： 


## 18. 删除链表的节点

### 1. 删除链表节点

- 题目： 给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点

### 2. 删除链表重复节点

- 题目：在一个**排序**的链表中，如何删除重复的节点


## 19. 正则表达式匹配

- 题目： 请事先一个函数用来匹配包含 '.' 和 '*' 的正则表达式。 '.' 表示任意一个字符， "*" 表示它前面的字符可以出现任意次（含0次）


## 20. 表示数值的字符串

- 题目： 请实现一个函数来判断字符串是否表示数值（包括整数和小数点）
- 举例： 正例："+100", "5e2", "-123", "3.1416", "-1E-16"； 反例："12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"




---

## 39. 数组中出现次数超过一半的数字

- 题目：数组中有一个数字出现的次数超过数组长度的一半， 请找出这个数字。
- 举例： [1,2,3,2,2,2,5,4,2]， 输出2

### 思路1：

**基于Partition 函数，时间复杂度为O(n)。**

- 分析： 数组中有一个数字出现的次数超过了数组长度的一般，这意味着如果对这个数组排序，那么排序后位于数组中间的数字一定就是那个出现次数超过数组长度一半的数字。
- 思路： 随机快排中partition的思想， 随机选择数组中的一个数，然后遍历数组，将比该数小的元素放在左边，比该数大的元素放在右边。 
  > - 如果选中的数字的下标刚好为n/2， 则这个数字就是数组的中位数
  > - 如果选中的数字的下标大于n/2 ， 则中位数位于数组的左边
  > - 如果选中的数字下标小于 n/2， 则中位数位于数组的右边

### 思路2：

**根据数组特点找出时间复杂度为O(n) 的算法**

- 分析： 数组中有一个数字出现的次数超过数组长度的一半，这意味着它出现的次数比其他所有数字出现次数的和还要多。
- 思路：从头到尾遍历数组，保存两个值：数组中的一个数字， 次数。 当我们遍历到下一个数字时：
  > - 如果下一个数字和我们之前保存的数字相同， 则次数+1
  > - 如果下一个数字和我们之前保存的数字不同， 则次数-1
  > - 若次数为0， 则我们保存下一个数字，并把次数设为1

### 测试用例
- 功能测试： 输入的数组中存在一个出现次数超过数组长度一般的数字； 输入的数组中不存在一个出现次数超过数组长度一半的数字

- 特殊输入测试： 输入数组中只有一个数字； 输入 nullptr 指针

## 最小k个数

- 题目： 输入n 个数， 找出其中最小的k个数。
- 举例： [4,5,1,6,2,7,3,8]， 则最小的4个数字为1，2，3，4

### 思路1：

**采用Partition 解决，时间复杂度为O(n)**

随机快排的思想， 找到划分点index， 如果 index == k-1, 则， 返回[:index]； 如果 index > k-1， 则在[:index-1]处在进行partition； 如果 index < k-1， 则在[index+1:] 进行partition。

### 思路2：

**采用一个大小为k的数据容器来存储最小的k个数字。**

依次遍历整个数组， 如果容器中的数字少于k个，则将数据有序插入容器之中。 如果容器中已有k个数字， 则将arr[i]， 与容器中的最大值比较，如果小于，则将arr[i]顺序插入容器，并将最大值弹出； 如果大于，则继续。

这个容器如果采用不同的数组的话，则时间复杂度为O(kn), 如果采用二叉树，红黑树，则只需要O(nlogk) 

### 测试用例

- 功能测试： 输入的数组中有相同的数字； 输入的数组中没有相同的数字
- 边界值测试： 输入的k等于1， 输入的k等于数组长度
- 特殊输入测试： k小于1； k 大于数组长度； 指向数组的指针为NULL


## 41. 数据流中的中位数

- 题目： 如何得到一个数据流中的中位数？如果数据流为奇数，则中位数为数据流排序后位于中间的数值。 如果数据流为偶数， 则为中间两个数的平均值。


## 42. 连续子数组的最大和

- 题目： 输入一个整型数组，数组中有正数也有负数。 数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
- 要求： 时间复杂度O(n)
- 举例： [1, -2, 3, 10, -4, 7, 2, -5]


### 思路1：

- 分析：一步一步加来分析数据规律。 


### 思路2：动态规划

我们采用函数 f(i) 来表示以第i个数字结尾的子数组的最大和，那么我们需要求出max[f(i)]:

- 如果 f(i-1) < 0 , 则 f(i) = arr[i]。
- 如果 f(i-1) > 0，则 f(i) = f(i-1) + arr[i].
- 边界： 当i = 0时， 返回arr[i]


## 43. 1-n 整数中1 出现的次数

- 题目： 输入一个整数n， 求 1-n 这n个整数的十进制表示中 1 出现的次数。
- 举例：输入12， 则有1, 10，11，12, 一共出现了5次



---

## 53. 在排序数组中查找数字

### 1. 数字在排序数组中出现的次数 -- occur_times

- 题目： 统计一个数字在排序数组中出现的次数。 

- 思路1： 采用二分查找找到该数字后，分别向左， 右两边扫描找到第一次出现和最后一次出现的位置，最后得到最终出现的次数。
- 思路2：直接找到第一次出现，最后一次出现的位置。
  > - 如果 arr[mid] > key, 则在[0:mid-1]位置查找
  > - 如果 arr[mid] < key, 则在 [mid+1:] 位置查找
  > - 如果 arr[mid] == key, 则判断 arr[mid] 是不是第一个key。 如果arr[mid-1] == key, 则说明第一个key 一定在 [0:mid-1] 段； 如果 arr[mid-1] != key， 则说明arr[mid]就是第一个key。

- 测试用例：
  > - 功能测试： 数组中包含要查找的数字； 数组中不包含要查找的数字； 要查找的数字在数组中出现一个或多次
  > - 边界测试： 查找数组中最大值，最小值； 数组只有一个数字
  > - 特殊输入： 数组为空

### 2. 0- n-1 中缺失的值： miss_val

- 题目： 一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0-n-1 之内。 并且每个数字都在范围0-n-1之内。 在范围0-n-1 的n 个数字中有且只有1个数字不再该数组中，请找出这个数字。

- 思路1： 用公式 n(n-1)/2 求出数字 0-n-1 的所有数字的和，记为s1； 接着求出数组中所有数字的和， 记为s2， 然后返回 s1 - s2 即可。
- 思路2： 从头到尾遍历数组， 遇到第一个 arr[i] != i 的， 输出i
- **思路3：** 采用二分查找，目的是找到第一个 arr[i] != i 的数。  如果 arr[mid] == mid ， 则需要向 [mid+1:]查找，如果 arr[mid] != mid ， 则先判断 arr[mid-1] == mid-1 ?, 如果不等于，则需要向 [:mid-1] 方向查找； 如果等于，则返回mid

- 测试用例：
  > - 功能测试： 缺失的值在数组开始， 中间， 末尾
  > - 边界测试： 数组中只有一个数字0
  > - 特殊输入测试： 空数组

### 3. 数组中数值和下标相等的元素

- 题目： 假设一个单调递增的数组里的每个元素都是整数且唯一。 请实现一个函数，找出数组中任意一个数值等于其下标的元素。 
- 举例： [-3, -1, 1, 3, 5] ， 返回3

- 思路1： 从头到尾遍历比较，如果arr[i] == i, 则返回i 
- 思路2： 采用二分查找， 如果arr[mid] > mid， 则在 arr[:mid-1]区间内查找； 如果arr[mid] == mid， 则返回mid； 如果 arr[mid] < mid， 则在 arr[mid+1:] 内查找。

- 测试用例：
  > - 功能测试： 数组中包含或不包含数值和下标相等的元素
  > - 边界值测试： 数组中只有一个数字； 数值和下标相等的元素位于数组的开头或结尾
  > - 特殊输入： 空数组


## 54. 二叉搜索树的第k大节点

- 题目： 给定一个二叉排序树，请找出其中第k大的节点。 

- 思路 ： 一次中序遍历得到一个有序数组arr， 返回arr[-k] 即可

- 测试用例：
> - 功能测试： 不同形态的二叉搜索树
> - 边界值测试： 输入k = 1，0，二叉搜索树节点数， 二叉搜索树节点数+1
> - 特殊输入测试：  根节点为 nullptr

## 55. 二叉树的深度

### 1. 二叉树的深度

- 题目： 输入一颗二叉树的根节点， 求该二叉树的深度。 从根节点到叶节点依次经过的节点（含根，叶）形成树的一条路径， 最长路径的长度为树的深度。

- 思路1： 找到所有路径的路径长度， 然后返回最长的路径长度。
- 思路2： 如果一棵树只有一个节点， 则它的深度为1； 如果根节点只有左子树而没有右子树， 那么树的深度 = 左子树深度+1； 如果根节点只有右子树而没有左子树， 则深度 = 右子树深度+1； 如果左，右子树都有， 则树的深度 =  左，右子树深度较大值 + 1

- 测试用例：

> - 功能测试： 输入普通的二叉树； 二叉树中所有节点都没有左/右子树
> - 特殊输入测试： 二叉树中只有一个节点； 二叉树的头节点为 nullptr 指针

### 2. 平衡二叉树

- 问题：输入一颗二叉树的根节点， 判断该树是不是平衡二叉树。 如果某二叉树中任意节点的左，右子树的深度相差不超过1， 则它就是一颗平衡二叉树。

- 思路1: 在遍历每个节点时， 调用TreeDepth 得到它的左，右子树的深度。 如果每个节点的左，右子树的深度相差不超过1， 则是一颗平衡二叉树。
- 思路2： 采用后序遍历的方式遍历二叉树的每个节点， 那么在遍历到一个节点之前我们就已经遍历了其左，右子树。 只要在遍历每个节点的时候记录它的深度，我们就可以一边遍历，一边判断每个节点是不是平衡的。

- 测试用例：
  > - 功能测试： 平衡的二叉树； 不平衡的二叉树； 二叉树中所有节点都没有左/右子树
  > - 特殊输入测试： 二叉树中只有一个节点； 二叉树的头节点为 nullptr 


## 56. 数组中数字出现的次数

### 1. 数组中只出现一次的两个数字

- 题目： 一个整形数组中除了两个数字外，其他数字都出现了两次，请写程序找出这两个只出现一次的数字。
- 要求： 时间复杂度：O(n)， 空间复杂度 : O(1)

- 举例：[2,4,3,6,3,2,5,5]， 返回4， 6
- 分析： 异或运算的性质： 任何一个数字异或它自己都等于0
- 思路： 从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字的异或记过，而这个结果的二进制表示中至少有一位为1。 我们找到第一个为1的位的位置，记为第n位。 我们现在以第n位是不是1为标准将原数组中的数字分为两个子数组，那么此时出现了两次的数字肯定被分配到同一子数组。 然后我们依次异或每个子数组，找出子数组中只出现一次的数字。 最后，返回这两个数字。

- 测试用例：
  > - 功能测试： 数组中有多对重复的数字； 数组中没有重复的数字

### 2. 数组中唯一只出现一次的数字

- 题目： 在一个数组中除一个数字只出现一次外，其余数字都出现了三次，请找出那个只出现一次的数字。

- 思路： 如果一个数字出现了三次， 则它的二进制上的每一位都出现了三次，我们将所有数字的二进制表示的每一位都加起来； 如果某一位能被3整除，只出现一次的数字该位为0， 否则为1

- 测试用例：
  > - 功能测试： 唯一只出现一次的数字分别是0， 正数， 负数； 重复出现三次的数字分别是0， 正数， 负数

## 57. 和为s的数字

### 1. 和为s的两个数字

- 题目： 输入一个递增排序的数组和一个数字s， 在数组中查找两个数， 使得它们的和正好是s。 如果有多对数字的和等于s， 则输出任意一对即可。

- 思路： 采用left， right 指针分别指向最左端，最右端。如果arr[left] + arr[right] > target, right--； 如果 arr[left] + arr[right] < target, left++； 如果 arr[left] + arr[right] == target, 返回 left, right。

- 测试用例：
  > - 功能测试： 数组中存在和为s的两个数； 数组中不存在和为s的两个数
  > - 特殊输入测试： 数组为空

### 2. 和为s的连续正数序列

- 题目：**输入一个正数s， 打印出所有和为s的连续正数序列(至少含有两个数)。**

- 思路：采用small， big 分别表示序列的最小值与最大值。 初始"small=1, big=2"， 如果从small...big的序列和 > s， 则small++； 如果small到big的序列和 < s ，则big++；若等于则打印。 直至增大到small == (1+s)/2 为止。

- 测试用例：
    > - 功能测试： 存在和为s的连续序列； 不存在和为s的连续序列
    > - 边界值测试： 连续序列的最小和3

## 58. 翻转字符串

### 1. 翻转单词顺序 

- 问题：输入一个英文句子， 翻转句子中单词的顺序，但单词内字符的顺序不变。 为了方便，标点符号和普通字母一样处理。

- 思路1： 采用一个栈， 将每个翻转后的单词压入栈中，然后弹出形成字符串返回
- 思路2： 先翻转句子中所有字符； 再翻转每个单词中字符顺序

- 测试用例：
  > - 功能测试： 句子中有多个单词； 句子中只有一个单词
  > - 特殊输入测试： 字符串为nullptr， 字符串为空， 字符串中只有空格
  
### 2. 左旋转字符串 

-  字符串的左旋转操作是将字符串前面若干字符转移到字符串的尾部。
-  举例： 输入“abcdefg", 2， 返回 "cdefgab"

- 思路1： 将前 [:num] 个字符与 [num+1:] 字符切分； 然后再[num+1:] + [num:] 连接
- 思路2： 先分别把[:num], [num+1:] 两部分翻转， 然后再将整个字符串翻转

- 测试用例：
  > - 功能测试： 把长度为n的字符串左旋转0，1，...， n， n+1个字符
  > - 特殊输入测试： 字符串指针为 nullptr

## 59. 队列的最大值

### 1. 滑动窗口的最大值

- 题目：**给定一个数组和滑动窗口的大小， 请找出所有滑动窗口里的最大值。**
- 举例： 输入：[2,3,4,2,6,2,5,1]，3， 那么最终返回[4,4,6,6,6,5]

- 思路1： 扫描每个滑动窗口的所有数字，并找出每个最大值。 如果滑动窗口大小为k， 则需要O(k) 时间找到最大值， 对于长度为n的输入数组，这种算法的时间复杂度为O(nk)
- 思路2：采用一个队列S， 注意S中存放的是元素的下标。 遍历数组arr：
  > - if S 为空， 则插入i
  > - if arr[i] > arr[S.first], 则清空S， S.first = i
  > - if S.size() == 2, arr[i] <= arr[S.end]， 则丢弃 arr[i]
  > - if S.size() ==2, arr[i] > arr[S.end]， 则 S.end = arr[i]
  > - if i+1 - S.first == 3, 则S.first 出队列

- 测试用例：
  > - 功能测试： 输入数组的数字大小无序； 输入数组的数字单调递增； 输入数组的数字单调递减
  > - 边界值测试： 滑动窗口大小为 0， 1， 等于输入数组长度， 大于输入数组长度
  > - 特殊输入测试： 数组为空


### 2. 队列的最大值

- 问题： **请定义一个队列并实现函数max 得到队列里的最大值。**
- 要求：函数max， push_back和 pop_front的时间复杂度为O(1)

- 思路： 采用双队列的形式，一个队列存储数据，一个队列存储当前最大值。

- 测试用例：
  > - 向队列末尾插入不同大小的数字并求最大值； 从队列头部删除数字并求最大值


## 60. n个骰子的点数

- 题目： **把n个骰子仍在地上， 所有骰子朝上一面的点数之和为s。 输入n， 打印所有s的所有可能的值出现的概率。**

- 分析： 骰子和最小为n， 最大为6n， 所有排列数有$6^n$。 我们要求出每个点数和出现的概率，然后除以$6^n$ 即可。

### 思路1：递归

将骰子分为两堆，第一堆只有1个（1-6中的任意一个数），另一堆有 n-1 个。 我们需要计算1-6的每一种点数和剩下n-1个筛子来计算点数和。 以此递归， 直至剩下一个骰子。

我们采用一个长度为6n-n+1 的数组将和为s的点数出现的次数保存到数组的第 s-n个元素里

### 思路2： 基于循环

采用两个数组来存储骰子点数的每个和出现的次数。 

在第一轮循环种， 第一个数组中的第n个数字表示筛子和为n出现的次数； 下一轮循环中， 加上一个 新的筛子， 则此时和为n的骰子出现的次数 = 上一轮循环中骰子点数和为 n-1, n-2, n-3, n-4, n-5, n-6 的次数的总和

- 测试用例：
  > - 功能测试： 1， 2， 3， 4， 个筛子的各个点数的概率
  > - 特殊输入测试： 0
  > - 性能测试： 11

## 61. 扑克牌的顺子

- 题目：从扑克牌中随机抽取5张牌， 判断是不是连续的。A 为1， J,Q,K 分别为 11， 12， 13。 大王，小王可以看成任意数字。

- 思路： 将大小王视作0. 首先将数组排序；然后统计数组中0的个数； 最后统计排序后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或等于0的个数，则这个数组就是连续的，反之，不连续。 如果排序后有相邻元素相等， 则不连续。

- 测试用例：
  > - 功能测试： 抽出的牌中有一个或多个大，小王； 抽出的牌中没有大王，小王； 抽出的牌中有对子
  > - 特殊输入测试： 输入 nullptr 指针

## 62. 圆圈中最后剩下的数字

- 题目： **0,1...n-1 这n个数字排成一个圆圈， 从数字0开始， 每次从这个圆圈里删除第m个数字。 求出这个圆圈里剩下的最后一个数字。**

### 思路1： 环形链表模拟

构建一个含有n个节点的环形链表， 每次在这个链表中删除第m个节点。

### 思路2：

定义方程： f(n.m)， 表示每次在n个数字 0，..., n-1 中删除第m个数字最后剩下的数字




## 63. 股票的最大利润

- 题目： 假设把该股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

- 举例：[9,11,8,5,7,12,16,14], 则我们在价格为5的时候买入，在价格为16的时候卖出， 获得最大利润 11


- 思路：从头到尾遍历数组， 在扫描到第i个数字时， 记住之前 i-1 个数字中的最小值，然后计算最大利润即可

- 测试用例：
  > - 功能测试： 存储股票价格的数组无序，单调递增， 单调递减
  > - 边界值测试： 存储股票价格的数组中只有两个数字
  > -  特殊输入测试： 指向数组的指针为 nullptr


## 64. 求 1+2+...+n

- 题目： **求1+2+...+n。 要求不能使用乘除法， for， while， if， else， switch， case 等关键字及条件判断语句。**


## 66 . 构建乘积数组



---

## 7.1 字符串转化为整数

- 考虑边界情况： 空字符， 空指针， 正负号， 溢出，非数字字符


## 7.2 树中两个节点的最低公共祖先

