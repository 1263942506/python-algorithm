

## 面试题1：赋值运算符函数 -- assignOperator.cc

- 题目： 如下为类型 CMyString 的声明， 请为该类型添加赋值运算

```
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);

private:
    char* m_pData;
}
```

- 定义赋值运算符函数时的要点：
> - 是否把返回值的类型声明为该类型的引用，并在该函数结束前返回实例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值，否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。


## 面试题3：数组中重复的数字

- 题目： 找出数组中重复的数字。在一个**长度为n**的数组里的所有数字都在**0到n-1**的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

- 方案1： 双重循环 ： $O(n^2)$ -- 不推荐

- 方案2： 先排序，后查找: $O(nlogn)$

- 方案3： 哈希表: 时间--$O(n)$， 空间--$O(n)$

### 最佳方案

- 分析： 数组中的数字都在 $0 -- n-1$ 之间。如果这个数组中没有重复的数字，那么当数组排序后数字i将出现在下标为i的位置。这也意味着，如果数组中有重复的数字，那么在某些位置上就有多个数字，而有些位置可能没有数字。

- 思路： 数组为[2,3,1,0,2,5,3]， 从第0个数字开始， 数字为2， 与它的小标不符， 于是把它和下标为2的数字1 互换， 交换后的数组变为 [1, 3, 2, 0, 2, 5], 此时第0个数字为1， 仍然与它的下标不相等，继续把它和下标为1的数字数字3交换，得到数组 [3, 1, 2, 0, 2, 5, 3]。 接下来继续交换第0个数字3和第3个数字0， 得到数组[0, 1, 2, 3, 2, 5, 3]。此时第0个数字的数值为0， 接着扫描下一个数字， 下面的几个数字中， 下标为1， 2， 3 的三个数字，其下标和数值都分别相等，因此不需要执行任何操作。 接下来扫描到下标为4 的数字2， 由于它的数值与它的下标不相等，再比较它与下标为2的数字，注意到此时数组中下标为2 的数字也是2， 因此我们就得出了这个重复数字2。

### 单元测试

- 长度为n的数组中包含一个或多个重复数字
- 数组中不包含重复数字。
- 无效的输入测试用例： 空指针，长度为n的数组包含 0-n-1 之外的数字

## 面试题4： 二维数组的查找

- 题目： 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

- 方案1： 双重循环，顺序查找，最多加上折半

### 最佳方案

- 分析： 如果数组中的数字小于要查找的数字，则要查找的数字应该在当前数字位置的右边或下边； 如果选取的数字大于要查找的数字，那么要查找的数字应该在当前数字位置的上边或左边。

![](http://ww1.sinaimg.cn/large/006gOeiSly1g0axrjvz40j30jr0ab77i.jpg)

- 思路：首先选取数组中右上角（从左下角也可）数字。 如果该数字等于要查找的数字，则查找过程结束； 如果该数字大于要查找的数字，则剔除这个数字所在的列； 如果该数字小于要查找的数字，则剔除这个数字所在的行。


### 单元测试

- 二维数组中包含查找的数字
- 二维数组中没有查找的数字
- 特殊输入： 空指针


## 面试题5： 替换空格

- 题目： 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

- 思考： 一个空格字符在替换后变成'%', '2', '0' 三个字符，因此字符串会变长。

### 思路1：转化为列表

思想： 遍历整个字符串， 当遇到是空格时，将'%20'存入列表中， 否则则将该字符存入列表中，最后再将列表转化为字符串。

时间复杂度为 O(n), 空间复杂度为 O(n + 2k), k为空格的数目。

### 思路2：

- 思想： 从头到尾遍历一次字符串，当遇到一个空格时，就将其转化为'20%'， 并移动后面的字符。 
  
时间复杂度：$O(n^2)$.


### 思路3：

在c系语言中，字符串是可变的， 因此可以采用空间复杂度，时间复杂度都较低的算法来实现。

- 思想： 首先计算出替换后的字符串长度。然后准备两个索引：index_origin, index_new； index_origin 指向原始字符串的末尾，index_new 指向替换之后的字符串的末尾。 从尾到头的用index_origin 遍历原始字符串，如果str[index_origin] != 空格， 则str[index_new] = str[index_origin]； 如果 str[index_origin] == 空格， 则分别复制 '0', '2', '%' 到str中, 直至 index_origin 遍历完毕。 


### 单元测试

- 输入的字符串包含空格
- 输入的字符串不包含空格
- 特殊输入： 字符串为nullptr指针，空字符串，只有一个空格字符，连续多个空格


## 面试题6： 从头到尾打印链表

- 题目： 输入一个链表的头结点，从尾到头的顺序返回一个数组。

### 思路1： 

- 思想： 从头到尾依次遍历链表，将每个节点的值放到一个栈中。 遍历结束后，再从栈顶逐个输出节点的值。

- 时间复杂度 O(n), 空间复杂度O(n)

### 思路2：

- 思想： 采用递归的方法。 我们没访问到一个节点时， 先递归输出其后面的节点，再输出该节点自身。

- 问题： 如果链表非常长，会导致函数调用的层级很深，从而可能导致栈溢出。

### 单元测试

- 链表有多个节点
- 链表只有一个节点
- 特殊输入测试： head = nullptr

## 面试题7： 重建二叉树

- 题目： 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树并返回。

- 思路： 采用递归的思想来做，与画树的思路一致，注意pre 与 vin的长度一致是一样的，重点就在于pre与vin的划分。

### 单元测试

- 普通二叉树： 完全二叉树，非完全二叉树
- 特殊二叉树： 所有结点都没有右孩子； 所有结点都没有左孩子； 只有一个结点
- 特殊输入： 为空， 前序与后序不匹配

## 面试题8： 二叉树的下一个结点

- 题目： 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

- 思路： 
  > - 如果一个结点有右子树，则它的下一个结点就是它的右子树中的最左子结点； 
  > - 如果没有右子树，且其为其父节点的左子结点， 则它的下一个结点就是它的父结点
  > - 如果没有右子树， 且它为它父节点的右子结点， 则我们需要沿着指向父节点的指针一直向上遍历，直到找到一个它是该父节点的左子结点。此时，该父节点就是我们要找的下一个结点。

### 单元测试

- 普通二叉树： 完全二叉树； 不完全二叉树
- 特殊二叉树： 所有结点都没有右孩子的二叉树； 所有结点都没有左孩子的二叉树； 只有一个结点的二叉树； 二叉树的根节点指针为nullptr
- 不同位置的结点的下一个结点： 下一个结点为当前结点的右子结点， 右子树的最左子结点， 父结点，跨层的父结点； 当前结点没有下一个结点


## 面试题9： 用两个栈实现队列

- 题目： 用两个栈来实现一个队列，完成队列的Push和Pop操作。

- 思路： 
  > - push： 直接将元素直接存入 stack1 中
  > - pop: 如果stack2为空，则将stack1 中元素压入到stack2中，再pop； 如果非空，则直接pop。

### 单元测试

- 向空的队列中添加，删除元素
- 向非空的队列中添加，删除元素
- 连续删除元素直至队列为空

## 面试题10： 斐波那契数列

### 题目1

输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）

$$
f(n)= \begin{cases} 0 \qquad n=0 \\ 1  \qquad n=1 \\ f(n-1) + f(n-2) \qquad n>1 \end{cases}
$$

- 思路1： 直接采用递归按照公式来做，计算量巨大，不推荐
- 思路2： 去掉重复运算，通过先计算f(2),f(3)依次计算，直至第n项


### 引申题目： 青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

- n=1 时， 1种跳法, 即 f(1) = 1
- n=2 时， 2种跳法, 即 f(2) = 2
- n>2 时， 第一次跳的时候有两种选择：
  > - 第一次只跳1级，则此时跳法数目 = 后面剩下n-1级的跳法数目 f(n-1)
  > - 第一次只跳2级，则此时跳法数目 = 后面剩下的 n-2 级台阶的跳法数目 f(n-2)
  因此有f(n) = f(n-1) + f(n-2)

### 终极引申

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

我们可以用归纳法推出： $f(n) = f(1) + ... + f(n-1) + 1 =  2^{n-1}$



### 单元测试

- 功能测试： 输入3， 5
- 边界测试： 0,1,2
- 性能测试： 较大的数：100


## 面试题11： 旋转数组的最小数字 -- min_number_of_RotateArray(需再看)

- 题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

### 思路 1：

找到第一个出现逆序的数字即可， 如在上例中{5,1} 是逆序的，因此最小值为1。
时间复杂度为 O(n)

### 思路2：

采用二分查找的思想来做： 定义指针位置p1:指向数组第一个元素 , p2：指向数组最后一个元素。 先找到中间元素 mid:
> - 如果 arr[mid] >= arr[p1], 则说明p1-mid 是有序的， 最小值不在该范围内： p1 = mid;  
> - 如果 arr[mid] <= arr[p2], 则说明 mid-p2是有序的， 最小值不在该范围内： p2 = mid;

最终，0-p1 表示的是前面递增数组的元素， p2- 表示后面递增数组的元素；最终，p1将指向前面递增子数组的最后一个元素， p2 将指向后面递增子数组的第一个元素， 且p2所在的位置就是最小的元素。 


### 单元测试

- 功能测试： 输入的数组是升序排序数组的一个旋转； 数组中有重复数字/没有
- 边界测试： 输入的数组是一个升序排序的数组；只包含一个数字的数组
- 特殊输入测试： nullptr指针


## 面试12：矩阵中的路径 -- 未完待续

- 问题： 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 
  a b t g 
  c f c s 
  j d e h 
  这样的3 X 4 矩阵中包含一条字符串"bfce"的路径，但是矩阵中不包含"abfb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。