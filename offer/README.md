

## 面试题1：赋值运算符函数 -- assignOperator.cc

- 题目： 如下为类型 CMyString 的声明， 请为该类型添加赋值运算

```
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);

private:
    char* m_pData;
}
```

- 定义赋值运算符函数时的要点：
> - 是否把返回值的类型声明为该类型的引用，并在该函数结束前返回实例自身的引用(*this)。只有返回一个引用，才可以允许连续赋值，否则，如果函数的返回值是void，则应用该赋值运算符将不能进行连续赋值。



## 面试题3：数组中重复的数字

- 题目： 找出数组中重复的数字。在一个**长度为n**的数组里的所有数字都在**0到n-1**的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

- 方案1： 双重循环 ： $O(n^2)$ -- 不推荐

- 方案2： 先排序，后查找: $O(nlogn)$

- 方案3： 哈希表: 时间--$O(n)$， 空间--$O(n)$

### 最佳方案

- 分析： 数组中的数字都在 $0 -- n-1$ 之间。如果这个数组中没有重复的数字，那么当数组排序后数字i将出现在下标为i的位置。这也意味着，如果数组中有重复的数字，那么在某些位置上就有多个数字，而有些位置可能没有数字。

- 思路： 数组为[2,3,1,0,2,5,3]， 从第0个数字开始， 数字为2， 与它的小标不符， 于是把它和下标为2的数字1 互换， 交换后的数组变为 [1, 3, 2, 0, 2, 5], 此时第0个数字为1， 仍然与它的下标不相等，继续把它和下标为1的数字数字3交换，得到数组 [3, 1, 2, 0, 2, 5, 3]。 接下来继续交换第0个数字3和第3个数字0， 得到数组[0, 1, 2, 3, 2, 5, 3]。此时第0个数字的数值为0， 接着扫描下一个数字， 下面的几个数字中， 下标为1， 2， 3 的三个数字，其下标和数值都分别相等，因此不需要执行任何操作。 接下来扫描到下标为4 的数字2， 由于它的数值与它的下标不相等，再比较它与下标为2的数字，注意到此时数组中下标为2 的数字也是2， 因此我们就得出了这个重复数字2。

### 单元测试

- 长度为n的数组中包含一个或多个重复数字
- 数组中不包含重复数字。
- 无效的输入测试用例： 空指针，长度为n的数组包含 0-n-1 之外的数字

## 面试题4： 二维数组的查找

- 题目： 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

- 方案1： 双重循环，顺序查找，最多加上折半

### 最佳方案

- 分析： 如果数组中的数字小于要查找的数字，则要查找的数字应该在当前数字位置的右边或下边； 如果选取的数字大于要查找的数字，那么要查找的数字应该在当前数字位置的上边或左边。

![](http://ww1.sinaimg.cn/large/006gOeiSly1g0axrjvz40j30jr0ab77i.jpg)

- 思路：首先选取数组中右上角（从左下角也可）数字。 如果该数字等于要查找的数字，则查找过程结束； 如果该数字大于要查找的数字，则剔除这个数字所在的列； 如果该数字小于要查找的数字，则剔除这个数字所在的行。


### 单元测试

- 二维数组中包含查找的数字
- 二维数组中没有查找的数字
- 特殊输入： 空指针