
## 例1： 时间复杂度

- 问题： 一个有序数组A， 另一个无序数组B， 请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M
- 算法1： 对于B中每一个数，都在A中通过遍历的方式查找  -- O(N*M)
- 算法2： 对于数组B中的每一个数，都在A中通过二分的方式查找  -- O(M * logN)
- 算法2： 先把数组B排序，然后用类似外排的方式打印所有在A中出现的数 -- O(M*logM) + O(N + M);
  > - b > a : a++
  > - b < a: print(b), b++
  > - b == a: b++

## 例2： 对数器

解决case不可控的问题

### 好处

- 可以不用依赖OJ，直接验证
- 小样本通过，但大样本失败时，对数器可以帮你
- 可以验证贪心策略

### 对数器

1. 随机样本产生器  -- generate_sample()
2. 准备一个绝对正确但复杂度不好的方法B（可能过不了OJ) -- B()
3. 比对方法， 验证B方法结果与你的方法是否相等 is_euqal()
4. 大样本测试，如果一个样本使得比对出错，打印样本分析是哪个方法出错
5. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确

**提前准备好模板：数组等数据结构**


## 例6： 递归

任何递归行为都可以改成非递归。

估计递归复杂度的通式：
$$
T(N) = aT(\frac{N}{b}) + O(N^d)
$$

> - N： 原样本量
> - N/b: 子过程的样本量
> - a： 子过程发生的次数
> - d： 除去调用子过程之外，剩下的代价

1. if $log_b a > d$, 则复杂度为 $O(N^log_b a)$
2. if $log_b a = d$, 则复杂度为 $O(N^d*logN)$
3. if $log_b a < d$, 则复杂度为 $O(N^d)$  


## 例8： 小和问题与逆序对问题

### 1. 小和问题  -- 值得再看

- 问题：在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和。求一个数组的小和。
- 思路： 利用归并排序的思想，在合并的时候计算小和。

### 2. 逆序对问题

在一个数组中,左边的数如果比右边的数大,则折两个数构成一个逆序对,请打印所有逆序对。


---

## 例1 

### 1. 划分数组 -- array_classify

- 题目： 给定一个数组arr和一个数num， 请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)
- 思路： 设定一个left，使得 arr[0]-arr[left-1] 中存储小于num的元素， 从头到尾遍历数组，如果arr[i] < num，则arr[left], arr[i] = arr[i], arr[left], 否则，跳过。

- 单元测试：
> - case 测试：
> - 边界测试：



### 2. 荷兰国旗问题 -- netherlands_flag

- 问题： 给定一个数组arr 和一个数num， 请把小于num的数放在数组的左边， 等于num的数放在数组的中间，大于num的数放在数组的右边
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)
- 思路： 设定一个left = 0, right = len(arr)-1, 让 arr[0]-arr[left-1] 存储小于num的元素， 让 arr[right+1] - arr[len(arr)-1] 存储大于num的元素， 从头到尾遍历数组：
  > - 如果arr[i] < num， 则 arr[left], arr[i] = arr[i], arr[left]; 
  > - 如果 arr[i] == num， 跳过; 
  > - 如果 arr[i] > num， 则 arr[right] arr[i] = arr[i], arr[right], 此时i 不变, 接着重复判断 arr[i] 。 
- 单元测试：
  > - case测试：
  > - 边界测试： 

## 例6： 比较器的使用



## 例8. 最大差值

- 问题： 给定一个无序数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N), 且要求不能用非基于比较的排序

- 思路： 
> - 划分桶： 桶数为N+1（N为数组长度）, 先遍历一遍数组，找到最大值max，最小值min， 按照最大值，最小值划分为N个桶
> - 装桶： 遍历数组，将元素放入对应的桶中， 桶中只保存**是否为空， 最小值，最大值**，其余数扔掉
> - 找桶： 最大差值一定不来自一个桶内部，且不一定来自空桶两侧的桶


---

## 题目1： 

- 题目： 用数组结构实现大小固定的队列和栈 -- stack_queue

- array_stack: 注意在大于init_size 抛出异常即可
- array_queue: start指向队列的首部， end 指向队列的尾部， size表示队列中元素长度; 需要注意一点，数组的空间是循环利用的。


## 题目2： 

- 题目： 实现一个特殊的栈,在实现栈的基本功能的基础上,再实现返回栈中最小元素的操作
- 要求： 
  > - pop, push, get_min 操作时间复杂度伟O(1)
  > - 设计的栈类型可以使用现成的栈结构

### 思路
> 采用两个栈，一个用来保存当前栈中的元素，其功能与一个正常的栈没有区别，记为StackData；另一个栈用于保存每一步的最小值，这个栈记为 StackMin。

### 实现方式1：

- push：假设当前压入数据为new_num。则先将其压入StackData中: 
> - 如果StackMin为空，则将new_num也压入到StackMin中
> - 如果不为空，则比较new_num 与 StackMin 栈顶元素，
>> - 如果 new_num <= 栈顶元素，则将new_num 压入到StackMin中
>> - 如果 new_num > 栈顶元素，则把StackMin栈顶元素重复压入到StackMin，即在栈顶元素上再压如一个栈顶元素

- pop：
> 在stackData中弹出数据，记为value；弹出StackMiin的栈顶元素，返回value。

- 查询当前栈中的最小值操作
> 返回StackMin的栈顶元素

### 实现方式2:

- push: 假设当前压入数据为new_num。则先将其压入StackData中: 
> - 如果StackMin为空，则将new_num也压入到StackMin中
> - 如果不为空，则比较new_num 与 StackMin 栈顶元素，
>> - 如果 new_num > 栈顶元素，则StackMin不压入任何元素
>> - 如果 new_num <= 栈顶元素，则将new_num 压入到StackMin中

- 弹出数据规则
> - 弹出StackData中的栈顶元素，记为value
>> - 若value == StackMin栈顶元素，StackMin弹出栈顶元素
>> - 若value > StackMin栈顶元素，stackMin不弹出栈顶元素，返回value

- 查询当前栈中最小值
> 返回StackMin的栈顶元素

### 方案1 与方案2 比较

- 相同点：
> 1. 都采用StackMin栈顶元素保存StackData每一步的最小值
> 2. 所有操作的时间复杂度都为O(1), 空间复杂度都为O(n)

- 不同点：
> - 方案1中StackMin压入时稍省空间，但是弹出操作稍费时间
> - 方案2中StackMin压入时稍省空间，但是弹出操作稍省时间


## 题目3：

### 如何仅用队列结构实现栈结构？

- 思路： 用两个队列实现栈， data 用于入元素， help 用于帮助返回元素：
  > - push: 将元素存入data中
  > - pop: 
    >> - 如果data非空, 将queue1中元素入队列到queue2中(除最后一个元素)，输出最后一个元素; data 与 help 交换
    >> - 如果data为空，则抛出异常

### 如何仅用栈结构实现队列结构?

- 思路：采用两个栈实现队列， stack1 
  > - enqueue： 直接将元素直接存入 stack1 中
  > - dequeue: 
    >> - 如果stack1， stack2都为空，则抛出异常
    >> - 如果stack2为空，则将stack1 中元素压入到stack2中，再pop； 
    >> - 如果stack2非空，则直接pop。

## 题目4： 猫狗队列

```
public class Pet { 
    private String type;
    public Pet(String type) { this.type = type; }
    public String getPetType() { return this.type; }
}
public class Dog extends Pet { 
    public Dog() { super("dog"); } 
}
public class Cat extends Pet { 
    public Cat() { super("cat"); } 
}
```

实现一种狗猫队列的结构,要求如下: 
> - 用户可以调用add方法将cat类或dog类的实例放入队列中; 
> - 用户可以调用pollAll方法,将队列中所有的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用pollDog方法,将队列中dog类的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用pollCat方法,将队列中cat类的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用isEmpty方法,检查队列中是否还有dog或cat的实例; 
> - 用户可以调用isDogEmpty方法,检查队列中是否有dog类的实例; 
> - 用户可以调用isCatEmpty方法,检查队列中是否有cat类的实例。

### 思路

- 思路： 给猫，狗，打上进入进入顺序即可
- add： 
- pollAll： 
- pollDog：
- pollCat：


### 思路2：

采用hashtable来做

## 题目5： 转圈打印矩阵

- 题目： 给定一个整型矩阵matrix,请按照转圈的方式打印它。
- 举例： [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 打印结果为： [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11, 10]
- 要求： 额外空间复杂度 O(1)
- 思路： 采用左上角(start_row,start_col)，右下角(end_row, end_col)。 先打印外圈的边界，然后采用递归的思想，递归的打印内圈的边界。


## 题目6： 旋转正方形矩阵

- 题目： 给定一个整型正方形矩阵 matrix， 请把该矩阵调整为顺时针旋转90度的样子
- 要求： 空间复杂度为O(1)
- 思路： 采用左上角(start_row,start_col)，右下角(end_row, end_col)，先将外圈的数据交换，然后递归的进行内圈的交换。这需要观察数据得出交换的规律。
  四个点分别为： `arr[start_row][start_col+i]， arr[start_row+i][end_col], arr[end_row][end_col-i], arr[end_row-i][start_row]`
  
```
times = start_col - start_row
for(i=0; i< times; i++){
    tmp = 
    
}
```

## 题目7： 反转单向和双向链表

- 题目： 分别实现反转单向链表和反转双向链表的函数
- 要求： 如果链表长度为N,时间复杂度要求为O(N),额外空间复杂度要求为O(1)


## 题目8： “之”字形打印矩阵

- 题目： 给定一个矩阵matrix,按照“之”字形的方式打印这个矩阵
- 举例: 
  ```
  1     2   3   4 
  5     6   7   8 
  9     10  11  12
  ```
  “之”字形打印的结果为:
  ```
  1     2   5   9
  6     3   4   7
  10    11  8   12
  ```

- 思路： 打印对角线


## 题目9： 在行，列都排好序的矩阵中找数

- 题目： 给定一个有N*M的整型矩阵matrix和一个整数K, matrix的每一行和每一 列都是排好序的。实现一个函数,判断K是否在matrix中。 
- 举例： 
  0 1 2 5 
  2 3 4 7 
  4 4 4 8 
  5 7 7 9
  如果K为7,返回true;如果K为6,返回false。

- 要求： 时间复杂度为O(N+M), 空间复杂度为O(1)

- 思路： 从右上角开始遍历
  > - if arr[i][j] > val , j--
  > - if arr[i][j] < val , i++


## 题目10： 打印两个有序链表的公共部分

- 题目： 给定两个有序链表的头指针head1和head2,打印两个链表的公共部分。
- 思路类似归并排序的merge过程


## 题目11： 判断一个链表是否为回文结构

- 题目： 给定一个链表的头节点head,请判断该链表是否为回文结构。
- 举例： 例如: 1->2->1,返回true。 1->2->2->1,返回true。15->6->15,返回true。 1->2->3,返回false。
- 要求： 如果链表长度为N,时间复杂度达到O(N),额外空间复杂度达到O(1)。

### 非原地思路

- 思路1： 利用一个栈，从头到尾逐个遍历整个链表，将每个结点压栈。 之后每遍历一个，就从栈中拿出一个比较，直至栈空。

- 思路2： 将后半段压栈。 首先，找到中间位置，采用快指针(step=2)， 慢指针(step=1)， 当快指针走完时，慢指针就到了中点的位置； 然后，将中点右部分的元素压入栈中； 最后，依次出栈，直至栈空。


### 原地思路

- 思路： 首先，找到中点； 然后，将中点右部分的元素链表反转； 最后，依次从头，尾开始遍历，直至中点。 最后将链表恢复。


## 题目12： 

> 将单向链表按某值划分成左边小、中间相等、右边大的形式

- 题目： 给定一个单向链表的头节点head,节点的值类型是整型,再给定一个整数pivot。实现一个调整链表的函数,将链表调整为左部分都是值小于 pivot 的节点,中间部分都是值等于pivot的节点,右部分都是值大于 pivot的节点。除这个要求外,对调整后的节点顺序没有更多的要求。
- 举例： 链表9->0->4->5->1,pivot=3。 调整后链表可以是1->0->4->9->5,也可以是0->1->9->5->4。
- 进阶要求： 
  > - 在左、中、右三个部分的内部也做顺序要求,要求每部分里的节点从左到右的顺序与原链表中节点的先后次序一致。
  > - 如果链表长度为N，时间复杂度为O(N), 空间复杂度为O(1)
- 举例： 链表9->0->4->5->1,pivot=3。调整后的链表是0->1->9->4->5

### 非稳定算法

- 思路： 将结点放入到数组中， 然后用荷兰国旗问题解决, 但荷兰国旗问题没有稳定性

### 稳定算法

- 思路： 用less 指向第一个 < val  的结点； equal 指向第一个 == val 的结点； large 指向第一个 > val 的结点；再从头到尾遍历链表，然后分别归类；最后将三个子链表相连。

- 我的思路： 将 head 作为less， 将最后一个元素作为 large和equal


## 题目13：

> 复制含有随机指针节点的链表

- 题目： 一种特殊的链表节点类描述如下, Node类中的value是节点值,next指针和正常单链表中next指针的意义一 样,都指向下一个节点,rand指针是Node类中新增的指针,这个指针可能指向链表中的任意一个节点,也可能指向null。 给定一个由 Node 节点类型组成的无环单链表的头节点head,请实现一个函数完成这个链表中所有结构的复制,并返回复制的新链表的头节点
```
public class Node { 
    public int value; 
    public Node next; 
    public Node rand;
    public Node(int data) { this.value = data; }
}
```
- 进阶要求： 不使用额外的数据结构,只用有限几个变量,且在时间复杂度为 O(N)内完成原问题要实现的函数。

### 非原地算法

- 思路： 采用哈希表

### 原地算法

- 思路： 将链表连接为 1-1'-2-2'-3-3'-null， 因此有 1'->next = 1->next->next, 1'->rand = 1->rand->next

## 题目14：

> 两个单链表相交的一系列问题

- 题目： 在本题中,**单链表可能有环,也可能无环**。给定两个单链表的头节点 head1和head2,这两个链表可能相交,也可能不相交。请实现一个函数, 如果两个链表相交,请返回相交的第一个节点;如果不相交,返回null 即可。
- 要求： 如果链表1 的长度为N,链表2的长度为M,时间复杂度请达到 O(N+M),额外空间复杂度请达到O(1)
- 思路：
  > - 判断俩链表是否有环
  > - 分为三种情况： 都无环；一个有环，一个无环； 都有环。

### 如何判断单链表是否有环

- 思路1： 采用哈希表存储结点是否曾经出现过； 
- 思路2： 采用快指针step=2)，慢指针(step=1)， 如果慢指针与快指针相遇 ，则说明链表有环； 此时快指针回到初始节点处，step=1， 此时，快指针和慢指针会在初始结点处相遇， 此时我们就得到了初始结点。

### 两个无环链表的相交结点

- 思路1： 采用哈希表来判断链表1与链表2是否有相交结点
- 思路2： 先遍历链表1，统计链表1的长度并拿到链表1的最后一个结点； 然后遍历链表2， 统计链表2的长度并拿到链表2的最后一个结点。 如果end1 != end2 ， 俩链表不可能相交； 如果end1==end2， 说明相交， 此时，需要找第一个相交结点， 链表1先走len1-len2步， 然后两个链表再一起走， 直到找到第一个相同结点。

### 一个链表有环，一个链表无环

- 结论： 不可能相交

### 两个链表都有环

主要有以下三种情况：
> - 两个链表有独立的环
> - 两个链表先相交， 相交的结点中包含环
> - 两个链表有共同的环

- 思路：首先，从头到尾遍历链表，并找到两个链表的环的初始结点： loop1,loop2。
  > - if loop1 == loop2, 则对应第二种情况， 说明两个链表相交， 此时需要找到第一个相交结点， 链表1 先走len1-len2步， 然后两个链表再一起走， 直到找到第一个相同结点。
  > - if loop != loop2， 则对应第一种或第三种情况，loop1 不断往下走，如果loop1能够遇到loop2，则是第三种情况， 此时，返回loo1， loop2都可； 如果直到loop1 结束都没有遇到loop2， 则是第一种情况。 

---

## 题目2： 

- 题目： 如何直观的打印一颗二叉树


## 题目3：

在二叉树中找到一个节点的后继节点

现在有一种新的二叉树节点类型如下:

```
public class Node 
{ 
    public int value; 
    public Node left;
    public Node right; 
    public Node parent;
    public Node(int data) { this.value = data; }
}
```
该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一 棵Node类型的节点组成的二叉树,树中每个节点的parent指针都正确地指向自己的父节点,头节点的parent指向null。
只给一个在二叉树中的某个节点 node,请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中, node的下一个节点叫作node的后继节点。

- 思路： 
  > - 如果一个结点有右子树，则它的下一个结点就是它的右子树中的最左子结点； 
  > - 如果没有右子树，沿着parent指针向上追溯，直到找到该节点属于某个父结点的左孩子， 返回该父结点； 如果追溯到根节点都找不到， 返回None


## 题目4：

- 题目： 二叉树的序列化和反序列化

- 序列化：将二叉树记录为文件
- 反序列化：从文件中读取记录形成二叉树

### 序列化
```
            1
        2       3
     4    5   6  7
```

- 先序遍历序列化： `1_2_4_#_#_5_#_#_3_6_#_#_7_#_#`
-  先序遍历反序列化： 