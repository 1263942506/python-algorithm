
## 例1： 时间复杂度

- 问题： 一个有序数组A， 另一个无序数组B， 请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M
- 算法1： 对于B中每一个数，都在A中通过遍历的方式查找  -- O(N*M)
- 算法2： 对于数组B中的每一个数，都在A中通过二分的方式查找  -- O(M * logN)
- 算法2： 先把数组B排序，然后用类似外排的方式打印所有在A中出现的数 -- O(M*logM) + O(N + M);
  > - b > a : a++
  > - b < a: print(b), b++
  > - b == a: b++

### 对数器

1. 随机样本产生器  -- generate_sample()
2. 准备一个绝对正确但复杂度不好的方法B（可能过不了OJ) -- B()
3. 比对方法， 验证B方法结果与你的方法是否相等 is_euqal()
4. 大样本测试，如果一个样本使得比对出错，打印样本分析是哪个方法出错
5. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确

**提前准备好模板：数组等数据结构**

### 好处

- 可以不用依赖OJ，直接验证
- 小样本通过，但大样本失败时，对数器可以帮你
- 可以验证贪心策略

## 题目3： 冒泡排序 -- pass

## 题目4： 选择排序 -- pass

## 题目5： 插入排序 -- pass

## 例6： 递归

**任何递归行为都可以改成非递归。**

估计递归复杂度的通式：
$$
T(N) = aT(\frac{N}{b}) + O(N^d)
$$

> - N： 原样本量
> - N/b: 子过程的样本量
> - a： 子过程发生的次数
> - d： 除去调用子过程之外，剩下的代价

1. if $log_b a > d$, 则复杂度为 $O(N^{log_b a})$
2. if $log_b a = d$, 则复杂度为 $O(N^{d} *logN)$
3. if $log_b a < d$, 则复杂度为 $O(N^d)$  

## 例7： 归并排序



## 例8： 小和问题与逆序对问题

### 1. 小和问题  -- 值得再看

- 问题：在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和。求一个数组的小和。
- 思路： 利用归并排序的思想，在合并的时候计算小和。

### 2. 逆序对问题

在一个数组中,左边的数如果比右边的数大,则折两个数构成一个逆序对,请打印所有逆序对。


---

## 例1 

### 1. 划分数组 -- array_classify

- 题目： 给定一个数组arr和一个数num， 请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)
- 思路： 设定一个left，使得 arr[0]-arr[left-1] 中存储小于num的元素， 从头到尾遍历数组，如果arr[i] < num，则arr[left], arr[i] = arr[i], arr[left], 否则，跳过。

- 单元测试：
> - case 测试：
> - 边界测试：



### 2. 荷兰国旗问题 -- netherlands_flag

- 问题： 给定一个数组arr 和一个数num， 请把小于num的数放在数组的左边， 等于num的数放在数组的中间，大于num的数放在数组的右边
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)
- 思路： 设定一个left = 0, right = len(arr)-1, 让 arr[0]-arr[left-1] 存储小于num的元素， 让 arr[right+1] - arr[len(arr)-1] 存储大于num的元素， 从头到尾遍历数组：
  > - 如果arr[i] < num， 则 arr[left], arr[i] = arr[i], arr[left]; 
  > - 如果 arr[i] == num， 跳过; 
  > - 如果 arr[i] > num， 则 arr[right] arr[i] = arr[i], arr[right], 此时i 不变, 接着重复判断 arr[i] 。 
- 单元测试：
  > - case测试：
  > - 边界测试： 

## 例6： 比较器的使用



## 例8. 最大差值

- 问题： 给定一个无序数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N), 且要求不能用非基于比较的排序

- 思路： 
> - 划分桶： 桶数为N+1（N为数组长度）, 先遍历一遍数组，找到最大值max，最小值min， 按照最大值，最小值划分为N个桶
> - 装桶： 遍历数组，将元素放入对应的桶中， 桶中只保存**是否为空， 最小值，最大值**，其余数扔掉
> - 找桶： 最大差值一定不来自一个桶内部，且不一定来自空桶两侧的桶


---

## 题目1： 

- 题目： 用数组结构实现大小固定的队列和栈 -- stack_queue

- array_stack: 注意在大于init_size 抛出异常即可
- array_queue: start指向队列的首部， end 指向队列的尾部， size表示队列中元素长度; 需要注意一点，数组的空间是循环利用的。


## 题目2： 

- 题目： 实现一个特殊的栈,在实现栈的基本功能的基础上,再实现返回栈中最小元素的操作
- 要求： 
  > - pop, push, get_min 操作时间复杂度伟O(1)
  > - 设计的栈类型可以使用现成的栈结构

### 思路
> 采用两个栈，一个用来保存当前栈中的元素，其功能与一个正常的栈没有区别，记为StackData；另一个栈用于保存每一步的最小值，这个栈记为 StackMin。

### 实现方式1：

- push：假设当前压入数据为new_num。则先将其压入StackData中: 
> - 如果StackMin为空，则将new_num也压入到StackMin中
> - 如果不为空，则比较new_num 与 StackMin 栈顶元素，
>> - 如果 new_num <= 栈顶元素，则将new_num 压入到StackMin中
>> - 如果 new_num > 栈顶元素，则把StackMin栈顶元素重复压入到StackMin，即在栈顶元素上再压如一个栈顶元素

- pop：
> 在stackData中弹出数据，记为value；弹出StackMiin的栈顶元素，返回value。

- 查询当前栈中的最小值操作
> 返回StackMin的栈顶元素

### 实现方式2:

- push: 假设当前压入数据为new_num。则先将其压入StackData中: 
> - 如果StackMin为空，则将new_num也压入到StackMin中
> - 如果不为空，则比较new_num 与 StackMin 栈顶元素，
>> - 如果 new_num > 栈顶元素，则StackMin不压入任何元素
>> - 如果 new_num <= 栈顶元素，则将new_num 压入到StackMin中

- 弹出数据规则
> - 弹出StackData中的栈顶元素，记为value
>> - 若value == StackMin栈顶元素，StackMin弹出栈顶元素
>> - 若value > StackMin栈顶元素，stackMin不弹出栈顶元素，返回value

- 查询当前栈中最小值
> 返回StackMin的栈顶元素

### 方案1 与方案2 比较

- 相同点：
> 1. 都采用StackMin栈顶元素保存StackData每一步的最小值
> 2. 所有操作的时间复杂度都为O(1), 空间复杂度都为O(n)

- 不同点：
> - 方案1中StackMin压入时稍省空间，但是弹出操作稍费时间
> - 方案2中StackMin压入时稍省空间，但是弹出操作稍省时间


## 题目3：

### 如何仅用队列结构实现栈结构？

- 思路： 用两个队列实现栈， data 用于入元素， help 用于帮助返回元素：
  > - push: 将元素存入data中
  > - pop: 
    >> - 如果data非空, 将queue1中元素入队列到queue2中(除最后一个元素)，输出最后一个元素; data 与 help 交换
    >> - 如果data为空，则抛出异常

### 如何仅用栈结构实现队列结构?

- 思路：采用两个栈实现队列， stack1 
  > - enqueue： 直接将元素直接存入 stack1 中
  > - dequeue: 
    >> - 如果stack1， stack2都为空，则抛出异常
    >> - 如果stack2为空，则将stack1 中元素压入到stack2中，再pop； 
    >> - 如果stack2非空，则直接pop。

## 题目4： 猫狗队列

```
public class Pet { 
    private String type;
    public Pet(String type) { this.type = type; }
    public String getPetType() { return this.type; }
}
public class Dog extends Pet { 
    public Dog() { super("dog"); } 
}
public class Cat extends Pet { 
    public Cat() { super("cat"); } 
}
```

实现一种狗猫队列的结构,要求如下: 
> - 用户可以调用add方法将cat类或dog类的实例放入队列中; 
> - 用户可以调用pollAll方法,将队列中所有的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用pollDog方法,将队列中dog类的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用pollCat方法,将队列中cat类的实例按照进队列的先后顺序依次弹出; 
> - 用户可以调用isEmpty方法,检查队列中是否还有dog或cat的实例; 
> - 用户可以调用isDogEmpty方法,检查队列中是否有dog类的实例; 
> - 用户可以调用isCatEmpty方法,检查队列中是否有cat类的实例。

### 思路

- 思路： 给猫，狗，打上进入进入顺序即可
- add： 
- pollAll： 
- pollDog：
- pollCat：


### 思路2：

采用hashtable来做

## 题目5： 转圈打印矩阵

- 题目： 给定一个整型矩阵matrix,请按照转圈的方式打印它。
- 举例： [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 打印结果为： [1,2,3,4,8,12,16,15,14,13,9,5,6,7,11, 10]
- 要求： 额外空间复杂度 O(1)
- 思路： 采用左上角(start_row,start_col)，右下角(end_row, end_col)。 先打印外圈的边界，然后采用递归的思想，递归的打印内圈的边界。


## 题目6： 旋转正方形矩阵

- 题目： 给定一个整型正方形矩阵 matrix， 请把该矩阵调整为顺时针旋转90度的样子
- 要求： 空间复杂度为O(1)
- 思路： 采用左上角(start_row,start_col)，右下角(end_row, end_col)，先将外圈的数据交换，然后递归的进行内圈的交换。这需要观察数据得出交换的规律。
  四个点分别为： `arr[start_row][start_col+i]， arr[start_row+i][end_col], arr[end_row][end_col-i], arr[end_row-i][start_row]`
  
```
times = start_col - start_row
for(i=0; i< times; i++){
    tmp = 
    
}
```

## 题目7： 反转单向和双向链表

- 题目： 分别实现反转单向链表和反转双向链表的函数
- 要求： 如果链表长度为N,时间复杂度要求为O(N),额外空间复杂度要求为O(1)


## 题目8： “之”字形打印矩阵

- 题目： 给定一个矩阵matrix,按照“之”字形的方式打印这个矩阵
- 举例: 
  ```
  1     2   3   4 
  5     6   7   8 
  9     10  11  12
  ```
  “之”字形打印的结果为:
  ```
  1     2   5   9
  6     3   4   7
  10    11  8   12
  ```

- 思路： 打印对角线


## 题目9： 在行，列都排好序的矩阵中找数

- 题目： 给定一个有N*M的整型矩阵matrix和一个整数K, matrix的每一行和每一 列都是排好序的。实现一个函数,判断K是否在matrix中。 
- 举例： 
  0 1 2 5 
  2 3 4 7 
  4 4 4 8 
  5 7 7 9
  如果K为7,返回true;如果K为6,返回false。

- 要求： 时间复杂度为O(N+M), 空间复杂度为O(1)

- 思路： 从右上角开始遍历
  > - if arr[i][j] > val , j--
  > - if arr[i][j] < val , i++


## 题目10： 打印两个有序链表的公共部分

- 题目： 给定两个有序链表的头指针head1和head2,打印两个链表的公共部分。
- 思路类似归并排序的merge过程


## 题目11： 判断一个链表是否为回文结构

- 题目： 给定一个链表的头节点head,请判断该链表是否为回文结构。
- 举例： 例如: 1->2->1,返回true。 1->2->2->1,返回true。15->6->15,返回true。 1->2->3,返回false。
- 要求： 如果链表长度为N,时间复杂度达到O(N),额外空间复杂度达到O(1)。

### 非原地思路

- 思路1： 利用一个栈，从头到尾逐个遍历整个链表，将每个结点压栈。 之后每遍历一个，就从栈中拿出一个比较，直至栈空。

- 思路2： 将后半段压栈。 首先，找到中间位置，采用快指针(step=2)， 慢指针(step=1)， 当快指针走完时，慢指针就到了中点的位置； 然后，将中点右部分的元素压入栈中； 最后，依次出栈，直至栈空。


### 原地思路

- 思路： 首先，找到中点； 然后，将中点右部分的元素链表反转； 最后，依次从头，尾开始遍历，直至中点。 最后将链表恢复。


## 题目12： 

> 将单向链表按某值划分成左边小、中间相等、右边大的形式

- 题目： 给定一个单向链表的头节点head,节点的值类型是整型,再给定一个整数pivot。实现一个调整链表的函数,将链表调整为左部分都是值小于 pivot 的节点,中间部分都是值等于pivot的节点,右部分都是值大于 pivot的节点。除这个要求外,对调整后的节点顺序没有更多的要求。
- 举例： 链表9->0->4->5->1,pivot=3。 调整后链表可以是1->0->4->9->5,也可以是0->1->9->5->4。
- 进阶要求： 
  > - 在左、中、右三个部分的内部也做顺序要求,要求每部分里的节点从左到右的顺序与原链表中节点的先后次序一致。
  > - 如果链表长度为N，时间复杂度为O(N), 空间复杂度为O(1)
- 举例： 链表9->0->4->5->1,pivot=3。调整后的链表是0->1->9->4->5

### 非稳定算法

- 思路： 将结点放入到数组中， 然后用荷兰国旗问题解决, 但荷兰国旗问题没有稳定性

### 稳定算法

- 思路： 用less 指向第一个 < val  的结点； equal 指向第一个 == val 的结点； large 指向第一个 > val 的结点；再从头到尾遍历链表，然后分别归类；最后将三个子链表相连。

- 我的思路： 将 head 作为less， 将最后一个元素作为 large和equal


## 题目13：

> 复制含有随机指针节点的链表

- 题目： 一种特殊的链表节点类描述如下, Node类中的value是节点值,next指针和正常单链表中next指针的意义一 样,都指向下一个节点,rand指针是Node类中新增的指针,这个指针可能指向链表中的任意一个节点,也可能指向null。 给定一个由 Node 节点类型组成的无环单链表的头节点head,请实现一个函数完成这个链表中所有结构的复制,并返回复制的新链表的头节点
```
public class Node { 
    public int value; 
    public Node next; 
    public Node rand;
    public Node(int data) { this.value = data; }
}
```
- 进阶要求： 不使用额外的数据结构,只用有限几个变量,且在时间复杂度为 O(N)内完成原问题要实现的函数。

### 非原地算法

- 思路： 采用哈希表

### 原地算法

- 思路： 将链表连接为 1-1'-2-2'-3-3'-null， 因此有 1'->next = 1->next->next, 1'->rand = 1->rand->next

## 题目14：

> 两个单链表相交的一系列问题

- 题目： 在本题中,**单链表可能有环,也可能无环**。给定两个单链表的头节点 head1和head2,这两个链表可能相交,也可能不相交。请实现一个函数, 如果两个链表相交,请返回相交的第一个节点;如果不相交,返回null 即可。
- 要求： 如果链表1 的长度为N,链表2的长度为M,时间复杂度请达到 O(N+M),额外空间复杂度请达到O(1)
- 思路：
  > - 判断俩链表是否有环
  > - 分为三种情况： 都无环；一个有环，一个无环； 都有环。

### 如何判断单链表是否有环

- 思路1： 采用哈希表存储结点是否曾经出现过； 
- 思路2： 采用快指针step=2)，慢指针(step=1)， 如果慢指针与快指针相遇 ，则说明链表有环； 此时快指针回到初始节点处，step=1， 此时，快指针和慢指针会在初始结点处相遇， 此时我们就得到了初始结点。

### 两个无环链表的相交结点

- 思路1： 采用哈希表来判断链表1与链表2是否有相交结点
- 思路2： 先遍历链表1，统计链表1的长度并拿到链表1的最后一个结点； 然后遍历链表2， 统计链表2的长度并拿到链表2的最后一个结点。 如果end1 != end2 ， 俩链表不可能相交； 如果end1==end2， 说明相交， 此时，需要找第一个相交结点， 链表1先走len1-len2步， 然后两个链表再一起走， 直到找到第一个相同结点。

### 一个链表有环，一个链表无环

- 结论： 不可能相交

### 两个链表都有环

主要有以下三种情况：
> - 两个链表有独立的环
> - 两个链表先相交， 相交的结点中包含环
> - 两个链表有共同的环

- 思路：首先，从头到尾遍历链表，并找到两个链表的环的初始结点： loop1,loop2。
  > - if loop1 == loop2, 则对应第二种情况， 说明两个链表相交， 此时需要找到第一个相交结点， 链表1 先走len1-len2步， 然后两个链表再一起走， 直到找到第一个相同结点。
  > - if loop != loop2， 则对应第一种或第三种情况，loop1 不断往下走，如果loop1能够遇到loop2，则是第三种情况， 此时，返回loo1， loop2都可； 如果直到loop1 结束都没有遇到loop2， 则是第一种情况。 

---

## 题目2： 

- 题目： 如何直观的打印一颗二叉树


## 题目3：

在二叉树中找到一个节点的后继节点

现在有一种新的二叉树节点类型如下:

```
public class Node 
{ 
    public int value; 
    public Node left;
    public Node right; 
    public Node parent;
    public Node(int data) { this.value = data; }
}
```
该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一 棵Node类型的节点组成的二叉树,树中每个节点的parent指针都正确地指向自己的父节点,头节点的parent指向null。
只给一个在二叉树中的某个节点 node,请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中, node的下一个节点叫作node的后继节点。

- 思路： 
  > - 如果一个结点有右子树，则它的下一个结点就是它的右子树中的最左子结点； 
  > - 如果没有右子树，沿着parent指针向上追溯，直到找到该节点属于某个父结点的左孩子， 返回该父结点； 如果追溯到根节点都找不到， 返回None


## 题目4：

- 题目： 二叉树的序列化和反序列化

- 序列化：将二叉树记录为文件
- 反序列化：从文件中读取记录形成二叉树

### 序列化
```
            1
        2       3
     4    5   6  7
```

- 先序遍历序列化： `1_2_4_#_#_5_#_#_3_6_#_#_7_#_#`
-  先序遍历反序列化： 


## 题目5：

- 题目： 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

- 给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向。 
- 举例：N=1时，打印： down，  N=2时，打印： down down up

## 题目6：

- 题目：判断一棵二叉树是否是平衡二叉树

- 思路：采用递归的思想来解决。



## 题目7：

- 题目： 判断一棵树是否是搜索二叉树、判断一棵树是否是完全二叉树


### 搜索二叉树(二叉排序树)

- 二叉树的中序遍历的节点是依次升序的，则说明该二叉树是搜索二叉树。

### 完全二叉树

通过层序遍历的方式：
> -  如果一个节点有右节点，无左节点，直接返回 false
> -  如果一个节点，(有左孩子，无右孩子) 或  (无左，右孩子)， 则后续的所有节点必须无左，右孩子； 否则，返回false
> -  若有左，右孩子，接着遍历


## 题目8：

-  已知一棵完全二叉树，求其节点的个数
-  要求： 时间复杂度低于O(N)，N为这棵树的节点个数

- 思路： 
  > - 先通过遍历左子树来获得二叉树的高度h
  > - 再查找右子树的左边界
  >> - 如果有，说明左子树是满的；左子树节点数为 $2^{h-level}$;  递归求取右子树节点
  >> - 如果没有， 说明右子树是满的； 右子树节点数为 $2^{h-level-1}$；递归求取左子树节点


  ---

## 题目2：

> 设计RandomPool结构

- 题目： 设计一种结构，在该结构中有如下三个功能：
  > - insert(key)：将某个key加入到该结构，做到不重复加入。
  > - delete(key)：将原本在结构中的某个key移除。 
  > - **getRandom()：等概率随机返回结构中的任何一个key。**
- 要求： Insert、delete和getRandom方法的时间复杂度都是 O(1)

- 思路： 
  > - getRandom需要等概率返回，因此需要使用两个hash表来实现 
  > - 对于delete， 为了防止删除key后，元素形成黑洞，因此需要先将最后一个元素与key交换，再删除。

## 题目3：布隆过滤器

https://zhuanlan.zhihu.com/p/43263751

## 题目4： 一致性哈希

https://zhuanlan.zhihu.com/p/34985026
https://blog.csdn.net/cywosp/article/details/23397179


## 题目5： 岛问题

- 题目： 一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？
- 举例： 以下矩阵中有3个岛
```
0 0 1 0 1 0
1 1 1 0 1 0
1 0 0 1 0 0
0 0 0 0 0 0
```

### 常规解法

- 思路： 感染的思想， 将每个得到的岛的数字变为2


---

## 前缀树



## 题目1：

- 题目： 两个字符串数组arr1， arr2， 问arr2中有哪些字符是arr1中出现的？ 请打印


## 题目4：

- 问题： 一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的 金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，怎么分最省铜板？
- 举例： [10,20,30], 代表一共三个人，整块金条长度为 10+20+30=60. 金条要分成10,20,30三个部分。
  > - 如果， 先把长度60的金条分成10和50，花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。
  > - 如果， 先把长度60的金条分成30和30，花费60 再把长度30金条分成10和20，花费30 一共花费90铜板。
  
  输入一个数组，返回分割的最小代价


### 思路

采用哈夫曼树的思想： 子节点合并在一起的代价是所有非叶节点加起来的和

- 思路： 先将所有的数加入小根堆
  > - 从小根堆中拿出两个最小的数，产生的代价为两数之和
  > - 然后将和扔到小根堆中，
  > - 重复上述过程，直至堆大小为1

## 题目5：

- 问题： 输入： 正数数组costs， 正数数组profits， 正数k， 正数m
  > - costs[i]: 表示i号项目的花费
  > - profits[i]: 表示i号项目在扣除花费之后还能挣到的利润
  > - k: 表示你只能串行最多做k个项目
  > - m： 你的初始资金

- 说明： 你每做完一个项目，马上获得的收益，可以支持你去做下一个 项目。
- 输出： 你最后获得的最大钱数。

### 思路

- 先将costs 与profits组织形成新的数组[costs[i], profits[i]]
- 将新的数组按照costs[i]来形成小根堆，堆顶是花费最少的项目
- 根据初始资金m， 依次弹出头部， 将所有costs[i] < m 的都弹出来
-  将弹出的数据放到大根堆，该大根堆是按照profits[i]来排序，取堆顶的项目来做， 更新m
-  再回到小根堆， 将小根堆中 costs[i] < 更新后的m的数据再放到大根堆中
-  依次反复，直到大根堆为空或次数大于k


## 题目8：

- 题目： 一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数组，里面 是一个个具体的项目)，你来安排宣讲的日程，要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。

### 思路

- 思路： 按照早结束的项目开始贪心， 淘汰不能做的项目， 依次类推，


---

## 题目1：

- 题目：求 n! 的结果


## 题目2：

- 题目： 汉诺塔问题： from， to， help
- 思路： 
  > - 先将 from中n-1 个元素移动到help中
  > - 再将元素N 从from移到 to中
  > - 最后将 n-1 个元素从help移动到 to中

## 题目3：

- 题目： 打印一个字符串全部子序列，包括空字符串


## 题目5：

- 问题： 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？ 


## 题目7：

- 题目： 给你一个二维数组， 二维数组中的每个数都是正数，要求从左上角走到右下角，每一步只能向右或向下，沿途经过的数字要累加。 返回最小的路径和。



## 题目8：

- 题目： 给一个数组arr， 一个整数aim。 如果可以任意选择arr中的数字，能不能累加得到aim，返回true或者false。

