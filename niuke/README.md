
## 例1： 时间复杂度

- 问题： 一个有序数组A， 另一个无序数组B， 请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M
- 算法1： 对于B中每一个数，都在A中通过遍历的方式查找  -- O(N*M)
- 算法2： 对于数组B中的每一个数，都在A中通过二分的方式查找  -- O(M * logN)
- 算法2： 先把数组B排序，然后用类似外排的方式打印所有在A中出现的数 -- O(M*logM) + O(N + M);
  > - b > a : a++
  > - b < a: print(b), b++
  > - b == a: b++




## 例2： 对数器

解决case不可控的问题

### 好处

- 可以不用依赖OJ，直接验证
- 小样本通过，但大样本失败时，对数器可以帮你
- 可以验证贪心策略

### 对数器

1. 随机样本产生器  -- generate_sample()
2. 准备一个绝对正确但复杂度不好的方法B（可能过不了OJ) -- B()
3. 比对方法， 验证B方法结果与你的方法是否相等 is_euqal()
4. 大样本测试，如果一个样本使得比对出错，打印样本分析是哪个方法出错
5. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确

**提前准备好模板：数组等数据结构**


## 例6： 递归

任何递归行为都可以改成非递归。

估计递归复杂度的通式：
$$
T(N) = aT(\frac{N}{b}) + O(N^d)
$$

> - N： 原样本量
> - N/b: 子过程的样本量
> - a： 子过程发生的次数
> - d： 除去调用子过程之外，剩下的代价

1. if $log_b a > d$, 则复杂度为 $O(N^log_b a)$
2. if $log_b a = d$, 则复杂度为 $O(N^d*logN)$
3. if $log_b a < d$, 则复杂度为 $O(N^d)$  


## 例8： 小和问题与逆序对问题

### 1. 小和问题  -- 值得再看

- 问题：在一个数组中,每一个数左边比当前数小的数累加起来,叫做这个数组的小和。求一个数组的小和。
- 思路： 利用归并排序的思想，在合并的时候计算小和。

### 2. 逆序对问题

在一个数组中,左边的数如果比右边的数大,则折两个数构成一个逆序对,请打印所有逆序对。


---

## 例1 

### 1. 划分数组 -- array_classify

- 题目： 给定一个数组arr和一个数num， 请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)
- 思路： 设定一个left，使得 arr[0]-arr[left-1] 中存储小于num的元素， 从头到尾遍历数组，如果arr[i] < num，则arr[left], arr[i] = arr[i], arr[left], 否则，跳过。

- 单元测试：
> - case 测试：
> - 边界测试：



### 2. 荷兰国旗问题 -- netherlands_flag

- 问题： 给定一个数组arr 和一个数num， 请把小于num的数放在数组的左边， 等于num的数放在数组的中间，大于num的数放在数组的右边
- 要求： 空间复杂度为O(1)， 时间复杂度为O(N)
- 思路： 设定一个left = 0, right = len(arr)-1, 让 arr[0]-arr[left-1] 存储小于num的元素， 让 arr[right+1] - arr[len(arr)-1] 存储大于num的元素， 从头到尾遍历数组：
  > - 如果arr[i] < num， 则 arr[left], arr[i] = arr[i], arr[left]; 
  > - 如果 arr[i] == num， 跳过; 
  > - 如果 arr[i] > num， 则 arr[right] arr[i] = arr[i], arr[right], 此时i 不变, 接着重复判断 arr[i] 。 
- 单元测试：
  > - case测试：
  > - 边界测试： 

