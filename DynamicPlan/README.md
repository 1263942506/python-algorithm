
## 例1 ：爬楼梯

- 来源： [leetcode 70]
- 题目： 在爬楼梯时， 每次可向上走1或2个台阶，问有n阶楼梯有多少种上楼方式


### 思路1：回溯法

- n == 1, f(n) = 1
- n ==2,  f(n) = 2
- n > 2, f(n) = f(n-1) + f(n-2)

时间复杂度太高，使得对于大规模数据太耗时。

### 思路2： 动态规划

#### 分析
- 思考： 到达楼梯的第i阶有多少种爬法，与第几阶的爬法直接相关， 如何递推求出第i阶爬法数量？

- 由于每次最多爬两阶， 楼梯的第i阶，只可能从楼梯第 i-1 阶与 第 i-2 阶到达，故达到第i阶有多少种爬法，只与第i-1阶， i-2阶的爬法数量直接相关。

第i阶的爬法数量 = 第 i-1 阶的爬法数量 + 第 i-2 阶的爬法数量

#### 动态规划

1. 原问题与子问题： 

#### 算法思路

1. 设置递推数组dp[0...n]， dp[i] 代表到达第i阶，有多少种走法，初始化数组元素为0
2. 设置到达第1阶台阶， 有 1  种走法； 到达第2个台阶，有2种走法
3. 利用i循环递推从第3阶到第n阶的结果：
   到达第i阶的数量 = 到达第 i-1 阶的数量 + 到达第 i-2 阶的数量


## 例2： 打家劫舍

- 来源： leetcode 198
- 问题： 在一条直线上， 有n个房屋，每个房屋中有数量不等的财宝， 有一个盗贼希望从房屋中盗取财宝，由于房屋中有报警器，如果同时从相邻两个房屋中盗取财宝就会触发报警器。 问在不触发报警器的前提下，最多可获取多少财宝？

### 思路1： 回溯

- n==1, f(n) = arr[0]
- n ==2, f(n) = max(arr[1], arr[9])
- n > 2, f(n) = max(f(n-1), f(n-2) + arr[n-1])

时间复杂度为 $O(2^n)$

### 思路2： 动态规划

#### 分析

- 原问题与子问题： 



