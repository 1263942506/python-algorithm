[TOC]

## 几大概念

### 1. 大O表示法

- 大O表示法：表示算法执行的最低上界。

对于对数复杂度的分析，常常会忽略是以2为底还是以其余为底的对数，因为不同底的对数之间是线性关系。

### 2. 时间复杂度

- 最坏时间复杂度： 最坏情况下，算法的时间复杂度
- 平均时间复杂度： 所有可能输入在等概率的情况下，算法的期望运行时间
- 最好时间复杂度： 最好情况下，算法的时间复杂度


$$
O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$

### 3. 递归的空间复杂度

递归调用是有空间代价的，在递归调用中，我们的递归的深度为多少，那么我们的空间复杂度就是多少。


## 时间复杂度分析

> 有一个字符串数组，将数组中的每一个字符串按照字母排序；之后，再将整个字符串数组按照字典序排序。整个操作的时间复杂度？

假设最长字符串长度为s， 数组中有n个字符串，那么则有：
- 对每个字符串排序时间复杂度为： `O(slogs)`
- 对数组中的每个字符串按照字母序排序： `O(n*slog(s))`
- 将整个字符串数组按照字典序排序： `O(s*nlog(n))`, 字符串之间总共需要比较 `O(nlogn) `次，但每个字符串比较时，比较 `O(n) `次

则总的时间复杂度为 `O(n * slog(s)) + O(s * n log(n)) = O(n * s * logs + s * n * logn)`

### 1. 数据规模

如果想在1s内解决问题：
- $O(n^2)$ 的算法可以处理大约 $10^4$ 级别的数据
- $O(n)$ 的算法可以处理大约 $10^8$ 级别的数据
- $O(nlogn)$ 的算法可以处理大约 $10^7$ 级别的数据

### 2. 递归算法的算法度分析

- 递归函数中，只进行一次递归调用(如：return f(n-1))，递归深度为 depth ， 在每个递归函数中，时间复杂度为T则总的时间复杂度为 `O(T * depth)`

- 递归函数中，进行多次递归调用(如：return f(n-1) + f(n-2))， 此时计算调用的次数， 此时通过画树来分析， 此时得到的往往是一个指数级的算法。

$$
T(N) = a * T(\frac{N}{b})  + O(N^d)
$$

> - N: 样本量
> - a: 子过程数量
> - b: 子样本切割数
> - d: 去除递归过程后的算法时间复杂度的指数部分

- 递归算法复杂度推算:
> - $log_ba > d$ : 复杂度为 $O(N^log_ba)$
> - $log_ba = d$, 复杂度为 $O(N^d * logN)$
> - $log(b,a) < d$, 复杂度为 O(N^d)

### 3. 均摊复杂度分析

有时候，随着数据量的增大，我们需要重新为数组分配空间，此时分配空间所花费的时间需要均摊到整个过程中。

如果数据规模的变化是不定的，我们在删除元素与增加元素的部分都需要设置重新分配空间，此时会产生一个复杂度震荡问题：即我们在临界点的位置不断删除，添加，一直重复这个过程，无法均摊，复杂度就变成 O(n) 了。


