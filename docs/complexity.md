
## 大O表示法

大O表示法：O(f(n)) 表示运行算法所需执行的指令数，和 f(n) 成正比。
在业界，我们就使用O来表示算法执行的最低上界。

值得一提的是，对于对数复杂度的分析，常常会忽略是以2为底还是以其余为底的对数，因为不同底的对数之间是线性关系的。

## 时间复杂度

- 最坏时间复杂度： 最坏情况下，算法的时间复杂度
- 平均时间复杂度： 所有可能输入在等概率的情况下，算法的期望运行时间
- 最好时间复杂度： 最好情况下，算法的时间复杂度


$$
O(1) < O(log_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
$$

## 空间复杂度

** 递归调用是有空间代价的，在递归调用中，我们的递归的深度为多少，那么我们的空间复杂度就是多少 **


## 时间复杂度分析

###  一个时间复杂度的例子

> 有一个字符串数组，将数组中的每一个字符串按照字母排序；之后，再将整个字符串数组按照字典序排序。整个操作的时间复杂度？

- 分析： 注意此时字符串数组的长度与每隔字符串的长度要分开讨论

假设最长字符串长度为s， 数组中有n个字符串，那么则有：
- 对每个字符串排序时间复杂度为： O(slogs)
- 对数组中的每个字符串按照字母序排序： O(n*slog(s))
- 将整个字符串数组按照字典序排序： O(s*nlog(n)), 字符串之间总共需要比较 O(nlogn) 次，但每个字符串比较时，比较 O(n) 次

则总的时间复杂度为 O(n * slog(s)) + O(s * n log(n)) = O(n * s * logs + s * n * logn)

### 数据规模

如果想在1s内解决问题：
> - $O(n^2)$ 的算法可以处理大约 $10^4$ 级别的数据
> - $O(n)$ 的算法可以处理大约 $10^8$ 级别的数据
> - $O(nlogn)$ 的算法可以处理大约 $10^7$ 级别的数据

### 复杂度分析： 如何快速判断你算法的时间复杂度

采用程序生成不同规模的数据，来通过不同数据规模所消耗的时间对比来判断算法的时间复杂度。

> - 当所消耗的时间随着数据规模的增大成倍数关系时，说明此时算法是O(n) 级别的
> - 当所消耗的时间随着数据的增大成1.?倍的关系，且?往往比较小时，说明此时是O(logn) 级别的

$$
\frac{log2N}{logN} = \frac(log2 + logN)}{logN} = 1 + \frac{log2}{logN}
$$

### 递归算法的算法度分析

** 不是有递归的函数就一定是 O(nlogn) 级别的，需要具体情况具体分析 **

- 递归函数中，只进行一次递归调用(如：return f(n-1))，递归深度为depth， 在每隔递归函数中，时间复杂度为T则总的时间复杂度为 O(T * depth)

- 递归函数中，进行多次递归调用(如：return f(n-1) + f(n-2)), 此时计算调用的次数， 此时通过画树来分析， 此时得到的往往是一个指数级的算法。（2-5）


### 均摊复杂度分析

有时候，随着数据量的增大，我们需要重新为数组分配空间，此时分配空间所花费的时间需要均摊到整个过程中。

如果数据规模的变化是不定的，我们在删除元素与增加元素的部分都需要设置重新分配空间，此时会产生一个复杂度震荡问题：即我们在临界点的位置不断删除，添加，一直重复这个过程，无法均摊，复杂度就编程 O(n) 了。

对于复杂度震荡问题，我们可以通过“当元素个数为数组容量的 $\frac{1}{4}$ 时，再进行resize”， 为再添加元素留出余地。
