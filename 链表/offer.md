
## 第二章
---
## 1. 从头到尾打印链表

- 来源： offer 6
- 题目：输入一个链表的头节点， 从尾到头反过来打印出每个节点的值。
- 思路1：空间复杂度O(n)， 采用一个列表保存链表所有节点，然后直接返回倒序数组。
- 思路2： 采用递归的思想来做。


## 第三章

### 1. 删除链表的节点

- offer 18
- 题目： 给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点
- 思路1：找到该节点的前一个节点，然后进行删除即可，时间复杂度O(n)
- 思路2：将该节点的下一个节点的值复制到该节点中，然后删除该节点的下一个节点。时间复杂度O(1). 
  如果输入节点为最后一个节点，则依旧需要找到该节点的前一个节点。
  如果链表中只有一个节点，则我们删除节点后还需要将链表头节点设置为nullptr

### 2. 删除链表中重复的节点

- 来源：offer 18
- 题目：**在一个排序的链表中，如何删除重复的节点？**
- 思路：维护一个指针表示重复元素指针，

- 测试用例：
  > - 功能测试：链表都为重复节点；  链表头部为重复节点, 即头结点也可能被删除； 链表尾部为重复节点； 链表中间有重复节点
  > - 特殊输入测试：链表为空

### 3. 链表中的倒数第 k 个节点

- 来源： offer 22
- 题目： 输入一个链表，输出该链表中倒数第k个节点。
- 思路： 设定一个指针，让该指针先走 k 步， 然后 两个指针一直走，直到第一个指针走到头。
- 测试用例： 
  > - 功能测试： 第 k 个节点在链表中间； 第 k 个节点是链表头结点； 第k个节点是链表尾结点
  > - 特殊输入测试： 链表头结点为 nullptr 指针； 链表的节点总数少于 k； k 为 0


### 4. 链表中环的入口节点

- 来源： offer 23
- 题目： 如果一个链表中包含环，如何找出环的入口节点
- 思路： 快慢指针。 快指针一次走两步，慢指针一次走一步，同时出发，在第一次相遇后，快指针回到起点，一次走一步，二者最终相遇的点就是环的入口节点。

- 测试用例：
  > - 功能测试：链表中包含或不包含环； 链表中有多个或只有1个节点
  > - 特殊输入测试： 输入为 None

### 5. 反转链表

- 来源： offer 24
- 题目： 定义1个函数， 输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

- 思路： 建立一个新的头结点，然后遍历链表，采用头插法将所有节点插入到新链表中
- 测试用例：
  > - 功能测试：输入链表含有多个节点； 链表中只有一个节点
  > - 特殊输入测试： 输入为空

### 6. 合并两个排序的链表

- 来源： offer 25
- 题目：输入两个递增排序的链表，合并两个链表并使新链表中的节点仍然是递增排序的
- 思路：哪个小取哪个， 最后把非空的接在新链表后面
- 测试用例：
  > - 功能测试：输入的两个链表有多个节点； 节点的值互不相同或存在值相等的多个节点
  > - 特殊输入测试：两个或一个为空链表； 两个链表中只有1个节点

## 第四章

### 1. 复杂链表的复制

- 来源： offer 35
- 题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）