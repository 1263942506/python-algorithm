
---
Easy

## 1. 反转链表

- 来源： **leetcode 206**

- 思路1：采用一个新的头结点new_head ， 依次访问原节点，将节点采用头插法插入到新节点中。
- 思路2： 递归的思路。

## 2. 链表相交

- 来源： **leetcode 160**
- 思路2： 先计算两个链表的长度，然后较长链表先移动 len_a - len_b 个位置，然后俩链表一起移动

## 3. 排序链表的合并

- 来源： leetcode 21
- 思路： 建立一个临时节点，每次取较小的那个节点来加入到新的链表中。

## 4. 回文链表

- 来源： leetcode 234
- 思路：采用栈的思想来做

---
Medium

## 1. 反转链表2

- 来源： **leetcode 92**
- 首先，要注意到 m=1 时的特殊情况， 当m=1时， 我们要从头开始逆置，但是没有前驱节点，因此，我们需要设置一个前驱节点
- 然后，我们要找到第一个要反转的节点 head， 并找到该节点的前置节点 pre
- 最后， 我们对 第 m+1 到第 n 个 节点采用头插法依次插入到链表中即可 

## 2. 环形链表

- 来源： **leetcode 141**

- 思路1：采用set， 不断遍历链表， 如果当前元素在集合中出现过，说明，链表中有环。

- 思路2： 快慢指针；快指针一次走两步，慢指针一次走一步，如果快慢指针最终相遇则说明有环。


## 3. 环形链表2 -- 142

- 思路： 采用快指针step=2)，慢指针(step=1)， 如果慢指针与快指针相遇 ，则说明链表有环； 此时快指针回到初始节点处，step=1， 此时，快指针和慢指针会在初始结点处相遇， 此时我们就得到了初始结点。

![](http://ww1.sinaimg.cn/large/006gOeiSly1g0qpdd0o5lj30yo0lf7dj.jpg)

## 4. 链表划分

- 来源： **leetcode 86**

- 思路：采用两个临时节点: low_head, high_head, 这两个节点不在链表中，这样分析会很简单。

## 5. 复制带随机指针的链表

- 来源： leetcode 138

- 思路1：采用字典来做， {原节点: 复制后的节点}。

  ```
  dict[原节点].next = dict[原节点.next]
  dict[原节点].random = dict[原节点.random]
  ```

  需要注意的是， 当next， random 指向空时需要特殊处理。

## 6. 两数相加

- 来源： **leetcode 2**
- 思路：

## 7. 排序链表 

- 来源： **leetcode 148**

- 思路： 采用归并的思想， 先划分，再合并

  > - 划分： 采用快慢指针来做
  > - 合并： 就两个链表合并

---

Hard

## 1.  合并k个有序链表

- 来源： leetcode 23

- 思路1： k个链表顺序合并k-1次(1,2合并，再与3合并)，此时的时间复杂度为 : 
$$
(n+n) + (2n+n) + ... + ((k-1)n + n) = (1+2+...+k-1)n + (k-1)n = (1+2+... + k)n - n = \frac{(k^2+k-1)}{2} * n = O(k^2*n)
$$

- 思路2： 将 k*n 个节点放到vector中，再将vector排序，然后将节点顺序相连。时间复杂度为：

$$
kN * logkN + kN = O(kN * logkN)
$$

- **思路3： 将k个链表进行分治，两两进行合并。 时间复杂度分析：**

  > - 第一轮，进行 k/2 次，每次处理 2n 个数字；
  > - 第二轮， 进行 k/4 次， 每次处理 4n 个数字
  > ...
  > - 最后一次， 进行 k/(2^logk) 次，每次处理 2^logk*N个值。
$$
2N * k / 2 + 4N * k/4 + ... + 2^logk * N *k /(2^logk) = Nk + ...+ Nk = O(kNlogk)
$$
