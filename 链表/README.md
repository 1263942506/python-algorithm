
## 1. 反转链表 -- 206

- **注意： 此处的head也存数据**

- 思路1：采用一个新的头结点new_head ， 依次访问原节点，将节点采用头插法插入到新节点中。
- 思路2： 采用一个新的头结点new_head ， 依次访问原节点，然后将节点逆序


## 2. 反转链表2 -- 92

- 思路：

  > - 首先，要注意到 m=1 时的特殊情况， 当m=1时， 我们要从头开始逆置，但是没有前驱节点，因此，我们需要设置一个前驱节点
  > - 然后，我们要找到第一个要反转的节点 head， 并找到该节点的前置节点 pre
  > - 最后我们对 第 m+1 到第 n 个 节点采用头插法依次插入到链表中即可 

## 3. 链表相交 -- 160

- 思路1： 采用集合，将A链表中节点对应的指针插入set，然后看看B链表中有没有一样的指针
- 思路2： 先计算两个链表的长度，然后较长链表先移动 len_a - len_b 个位置，然后俩链表一起移动

## 4. 环形链表 -- 141

- 思路1：采用set， 不断遍历链表， 如果当前元素在集合中出现过，说明，链表中有环。

- 思路2： 快慢指针；快指针一次走两步，慢指针一次走一步，如果快慢指针最终相遇则说明有环。


## 5. 环形链表2 -- 142

- 思路： 采用快指针step=2)，慢指针(step=1)， 如果慢指针与快指针相遇 ，则说明链表有环； 此时快指针回到初始节点处，step=1， 此时，快指针和慢指针会在初始结点处相遇， 此时我们就得到了初始结点。

![](http://ww1.sinaimg.cn/large/006gOeiSly1g0qpdd0o5lj30yo0lf7dj.jpg)


## 6. 链表划分 -- 86

- 思路：采用两个临时节点: low_head, high_head, 这两个节点不在链表中，这样分析会很简单。

## 7. 复制带随机指针的链表 -- 138

**此题比较经典， 需要反复做**

- 思路1：采用字典来做， {原节点: 复制后的节点}， 那么则有， dict[原节点].next = dict[原节点.next]， dict[原节点].random = dict[原节点.random]， 需要注意的是， 当next， random 指向空时需要特殊处理。
- 思路2：

## 8. 排序链表的合并 -- 21

- 思路： 采用一个临时节点会很方便，每次取较小的那个节点来加入到新的链表中。

## 9.  合并k个有序链表 -- 23

- 思路1： k个链表顺序合并k-1次(1,2合并，再与3合并)，此时的时间复杂度为 : 
$$
(n+n) + (2n+n) + ... + ((k-1)n + n) = (1+2+...+k-1)n + (k-1)n = (1+2+... + k)n - n = \frac{(k^2+k-1)}{2} * n = O(k^2*n)
$$

- 思路2： 将k*n个节点放到vector中，再将vector排序，然后将节点顺序相连。时间复杂度为：

$$
kN * logkN + kN = O(kN * logkN)
$$

- **思路3： 将k个链表进行分治，两两进行合并。 时间复杂度分析：**

  > - 第一轮，进行 k/2 次，每次处理 2n 个数字；
  > - 第二轮， 进行 k/4 次， 每次处理 4n 个数字
  > ...
  > - 最后一次， 进行 k/(2^logk) 次，每次处理 2^logk*N个值。
$$
2N * k / 2 + 4N * k/4 + ... + 2^logk * N *k /(2^logk) = Nk + ...+ Nk = O(kNlogk)
$$


