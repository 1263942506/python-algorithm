
# 第二章
---
## 1. 数组中重复的数字

- 来源： [offer 3](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)


### 1. 数组中重复的数字

- 思路1： 集合思想， 采用一个集合维护已经访问过的元素
- 思路2： 交换思想，数组本身做哈希。 在 nums[i] != i 时依次交换 nums[i]与 nums[nums[i]]的值。

### 2. 不修改数组找出重复的数字

二分思想： 将 1-n 的数字依据中间数组 m 划分， 则划分为两部分：前面一半范围为[1,m]， 后面一半范围为 [m+1, n]。 如果 [1,m] 中的数目超过 m，那么[1,m]这一半内一定包含重复的数字，反之，则重复数字在 [m+1,n]中。


## 2. 二维数组的查找

- 来源： **leetcode 4**
- 题目： 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。


- 分析： 如果数组中的数字小于要查找的数字，则要查找的数字应该在当前数字位置的右边或下边； 如果选取的数字大于要查找的数字，那么要查找的数字应该在当前数字位置的上边或左边。

- 思路：首先选取数组中右上角（从左下角也可）数字。 如果该数字等于要查找的数字，则查找过程结束； 如果该数字大于要查找的数字，则剔除这个数字所在的列； 如果该数字小于要查找的数字，则剔除这个数字所在的行。


- 单元测试
> - 二维数组中包含查找的数字
> - 二维数组中没有查找的数字
> - 特殊输入： 空指针


## 第三章

### 1. 调整数组的顺序 -- 未找到oj

- 来源： offer 21
- 题目： 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

- 思路1： 维护两个left， right指针



## 第五章
---

## 1. 数组中出现次数超过一半的数字

- 来源： offer 39
- 题目：数组中有一个数字出现的次数超过数组长度的一半， 请找出这个数字。
- 举例： [1,2,3,2,2,2,5,4,2]， 输出2

### 思路

**根据数组特点找出时间复杂度为O(n) 的算法**

- 分析： 数组中有一个数字出现的次数超过数组长度的一半，这意味着它出现的次数比其他所有数字出现次数的和还要多。
- 思路：从头到尾遍历数组，保存两个值：数组中的一个数字， 次数。 当我们遍历到下一个数字时：
  > - 如果下一个数字和我们之前保存的数字相同， 则次数+1
  > - 如果下一个数字和我们之前保存的数字不同， 则次数-1
  > - 若次数为0， 则我们保存下一个数字，并把次数设为1

### 测试用例
- 功能测试： 输入的数组中存在一个出现次数超过数组长度一般的数字； 输入的数组中不存在一个出现次数超过数组长度一半的数字

- 特殊输入测试： 输入数组中只有一个数字； 输入 nullptr 指针

## 2. 最小k个数

- 题目： 输入n 个数， 找出其中最小的k个数。
- 举例： [4,5,1,6,2,7,3,8]， 则最小的4个数字为1，2，3，4

### 思路1：Partition 思想

**采用Partition 解决，时间复杂度为O(n)**

随机快排的思想， 找到划分点index， 
> - 如果 index == k-1, 则， 返回[:index]； 
> - 如果 index > k-1， 则在[:index-1]处在进行partition； 
> - 如果 index < k-1， 则在[index+1:] 进行partition。

### 思路2：大根堆思想

**采用一个大小为k的大根堆来存储最小的k个数字。**

从头到尾遍历数组，如果元素比堆顶大，则弹出堆顶，并将该元素塞入。

### 测试用例

- 功能测试： 输入的数组中有相同的数字； 输入的数组中没有相同的数字
- 边界值测试： 输入的k等于1， 输入的k等于数组长度
- 特殊输入测试： k小于1； k 大于数组长度； 指向数组的指针为NULL

## 3. 数据流中的中位数 -- 难

- 来源： **offer 41**
- **题目： 如何得到一个数据流中的中位数？如果数据流为奇数，则中位数为数据流排序后位于中间的数值。 如果数据流为偶数， 则为中间两个数的平均值。**
- 思路：大根堆与小根堆思想。 大根堆中所有数据都要小于小根堆的数据。
  > -  如果大根堆，小根堆长度相等，则把数据与大根堆堆顶比较

## 4. 连续子数组的最大和

- 来源：offer 42
- 题目： 输入一个整型数组，数组中有正数也有负数。 数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
- 要求： 时间复杂度O(n)
- 举例： [1, -2, 3, 10, -4, 7, 2, -5]
- 思路1：循环。 
- 思路2：动态规划我们采用函数 f(i) 来表示以第i个数字结尾的子数组的最大和，那么我们需要求出max[f(i)]:
> - 如果 f(i-1) < 0 , 则 f(i) = arr[i]。
> - 如果 f(i-1) > 0，则 f(i) = f(i-1) + arr[i].
> - 边界： 当i = 0时， 返回arr[i]

## 5. 1-n 整数中1 出现的次数 -- 难

- 来源： offer 43
- 题目： **输入一个整数n， 求 1-n 这n个整数的十进制表示中 1 出现的次数。**
- 举例：输入12， 则有1, 10，11，12, 一共出现了5次
- 思路： 

## 6.  数字序列中某一位数字 -- 未找到oj
- 来源： offer 44
- 题目：数字以 0123454324的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）为5. 请写出一个函数，求任意第n位对应的数字。
  

## 7. 把数组排成最小的数
- 来源： offer 45
- 题目： 输入一个正整数数组，把数组中所有数字拼接成一个数，打印能拼接处的所有数字中最小的一个。
- 举例： [3, 32, 321]， 则打印 321323
- 思路： 对于两个数 n，m 如果nm < mn， 则将n放在m前面






# 第六章
---
## 1. 数组中数字出现的次数

来源： offer 56

### 1. 数组中只出现一次的两个数字

- 题目：** 一个整形数组中除了两个数字外，其他数字都出现了两次，请写程序找出这两个只出现一次的数字。**
- 要求： 时间复杂度：O(n)， 空间复杂度 : O(1)
-  坑： 此题用 python 写很麻烦，建议c++

- 举例：[2,4,3,6,3,2,5,5]， 返回4， 6
- 分析： 异或运算的性质： 任何一个数字异或它自己都等于0
- 思路： 从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字的异或记过，而这个结果的二进制表示中至少有一位为1。 我们找到第一个为1的位的位置，记为第n位。 我们现在以第n位是不是1为标准将原数组中的数字分为两个子数组，那么此时出现了两次的数字肯定被分配到同一子数组。 然后我们依次异或每个子数组，找出子数组中只出现一次的数字。 最后，返回这两个数字。

- 测试用例：
  > - 功能测试： 数组中有多对重复的数字； 数组中没有重复的数字

### 2. 数组中唯一只出现一次的数字  -- 未找到 oj

- 题目： 在一个数组中除一个数字只出现一次外，其余数字都出现了三次，请找出那个只出现一次的数字。

- 思路： 如果一个数字出现了三次， 则它的二进制上的每一位都出现了三次，我们将所有数字的二进制表示的每一位都加起来； 如果某一位能被3整除，只出现一次的数字该位为0， 否则为1

- 测试用例：
  > - 功能测试： 唯一只出现一次的数字分别是0， 正数， 负数； 重复出现三次的数字分别是0， 正数， 负数


## 2. 和为s的数字

- 来源： offer 57

### 1. 和为s的两个数字

- 题目： 输入一个递增排序的数组和一个数字s， 在数组中查找两个数， 使得它们的和正好是s。 如果有多对数字的和等于s， 则输出任意一对即可。

- 思路： 采用left， right 指针分别指向最左端，最右端。如果arr[left] + arr[right] > target, right--； 如果 arr[left] + arr[right] < target, left++； 如果 arr[left] + arr[right] == target, 返回 left, right。
- 坑： 需要注意边界

- 测试用例：
  > - 功能测试： 数组中存在和为s的两个数； 数组中不存在和为s的两个数
  > - 特殊输入测试： 数组为空

### 2. 和为s的连续正数序列

- 题目：**输入一个正数s， 打印出所有和为s的连续正数序列(至少含有两个数)。**

- 思路：采用small， big 分别表示序列的最小值与最大值。 初始"small=1, big=2"， 如果从small...big的序列和 > s， 则small++； 如果small到big的序列和 < s ，则big++；若等于则打印。 直至增大到small == (1+s)/2 为止。
- 坑： 思路需要明确，思路比较奇特。

- 测试用例：
    > - 功能测试： 存在和为s的连续序列； 不存在和为s的连续序列
    > - 边界值测试： 连续序列的最小和3

## 3. 扑克牌的顺子

- 来源： offer 61

- 题目：从扑克牌中随机抽取5张牌， 判断是不是连续的。A 为1， J,Q,K 分别为 11， 12， 13。 大王，小王可以看成任意数字。

- 思路： 将大小王视作0. 首先将数组排序；然后统计数组中0的个数； 最后统计排序后的数组中相邻数字之间的空缺总数。如果空缺的总数小于或等于0的个数，则这个数组就是连续的，反之，不连续。 如果排序后有相邻元素相等， 则不连续。

- 测试用例：
  > - 功能测试： 抽出的牌中有一个或多个大，小王； 抽出的牌中没有大王，小王； 抽出的牌中有对子
  > - 特殊输入测试： 输入 nullptr 
  
## 4. 圆圈中最后剩下的数字 -- Hard

**约瑟夫问题**

- 来源： offer 62

- 题目： **0,1...n-1 这n个数字排成一个圆圈， 从数字0开始， 每次从这个圆圈里删除第m个数字。 求出这个圆圈里剩下的最后一个数字。**

思路：

旧编号与链表index 的关系， 假设链表长度为3，关系为 链表index = 旧编号 % n ：
旧编号 链表index
0               0 
1               1
2               2
3               0

因为要删除

```
f(n,m) = 0, if n == 1
f(n,m) = (f(n-1,m) + m) % n, if n > 1
```

## 5. 股票的最大利润 -- 未找到oj

- 来源： offer 63

- 题目： 假设把该股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

- 举例：[9,11,8,5,7,12,16,14], 则我们在价格为5的时候买入，在价格为16的时候卖出， 获得最大利润 11


- 思路：从头到尾遍历数组， 在扫描到第i个数字时， 记住之前 i-1 个数字中的最小值，然后计算最大利润即可

- 测试用例：
  > - 功能测试： 存储股票价格的数组无序，单调递增， 单调递减
  > - 边界值测试： 存储股票价格的数组中只有两个数字
  > -  特殊输入测试： 指向数组的指针为 nullptr

  
## 6. 构建乘积数组

- 来源： offer 66
- 题目：给定一个数组 A[0,1,...,n-1]， 请构建一个数组 B[0, ...,n-1]， 其中B中的元素`B[i] =A[0] * A[1] * ... * A[i-1] * A[i+1] * ... *A[n-1]`， 不能使用除法。


- 思路： 定义 C[i] = A[0] * ... * A[i-1], D[i] = A[i+1] * ... * A[n-1]， 那么则有： C[i] = C[i-1] * A[i-1]， D[i] = D[i+1] * A[i+1]， 最终的 B[i] = C[i] * D[i]

- 坑： 思路比较难想

- 测试用例：
> - 功能测试： 输入数组包含正数，负数，一个0， 多个0
> - 边界值测试： 输入数组的长度为 0

