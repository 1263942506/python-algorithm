
## 第二章
---
## 1. 旋转数组的最小数字

- 来源： offer 11

- 题目： **把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。**

- 思路 1：找到第一个出现逆序的数字即可， 如在上例中{5,1} 是逆序的，因此最小值为1。时间复杂度为 O(n)
- 思路 2：依旧是为了找到第一个逆序的数字，采用二分查找的思想来做： 定义指针位置p1:指向数组第一个元素 , p2：指向数组最后一个元素。 先找到中间元素 mid:
> - 如果 arr[mid] >= arr[p1], 则说明 p1-mid 是有序的， 最小值不在该范围内： p1 = mid;  
> - 如果 arr[mid] <= arr[p2], 则说明 mid-p2是有序的， 最小值不在该范围内： p2 = mid;

最终，0-p1 表示的是前面递增数组的元素， p2- 表示后面递增数组的元素；最终，p1将指向前面递增子数组的最后一个元素， p2 将指向后面递增子数组的第一个元素， 且p2所在的位置就是最小的元素。 

- 单元测试
> - 功能测试： 输入的数组是升序排序数组的一个旋转； 数组中有重复数字/没有
> - 边界测试： 输入的数组是一个升序排序的数组；只包含一个数字的数组
> - 特殊输入测试： nullptr指针




## 53. 排序数组中查找数字

### 1. 数字在排序数组中出现的次数 - get_num_of_k

- 题目： **统计一个数字在排序数组中出现的次数**。例如：输入排序数组{1,2,3,3,3,3,4,5}和数字3， 由于3在这个数组中出现4次， 因此输出4.
- 思路：分别用二分查找找到出现的第一个3的坐标index1和最后一个3的坐标index2， 然后就得到结果： index2 - index1 + 1. 
- 坑： 此题的坑在于边界条件很多，导致写出完整代码比较困难。

> - get_first_k: 先找到中间位置 mid。如果 arr[mid] > k ， 则说明 k 只有可能出现在数组的前半段，那么则有 end = mid - 1; 如果 arr[mid] < k， 则说明 k 只有可能出现在数组的后半段， 那么则有 start = mid + 1; 如果 arr[mid] == k, 且arr[mid-1] 也为 k，那么就说明 mid就是第一个出现的 k，考虑到 mid可能为边界 0， 如果mid 为边界0， 那说明 0 就是第一个出现的k， 否则， 则说明第一个 k 在数组的前半段。
> - get_last_k: 先找到中间位置 mid。如果 arr[mid] > k ， 则说明 k 只有可能出现在数组的前半段，那么则有 end = mid - 1; 如果 arr[mid] < k， 则说明 k 只有可能出现在数组的后半段， 那么则有 start = mid + 1; 如果 arr[mid] == k, 且arr[mid+1] 也为 k，那么就说明 mid就是最后一个出现的 k，考虑到 mid可能为边界 len(data)-1， 如果mid 为边界len(data)-1， 那说明 len(data)-1 就是第一个出现的k， 否则， 则说明 最后一个 k 在数组的后半段。


- 测试用例：
> - 功能测试： 数组中包含要找的数字； 数组中没有要找的数组； 要查找的数字再数组中出现一次或多次
> - 边界测试： 查找数组中的最大值，最小值； 数组中只有一个数字
> - 特殊输入： 空数组

### 2. 0 - n-1 中缺失的数字 -- 未找到oj

- 题目： 一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0-n-1 之内。 并且每个数字都在范围0-n-1之内。 在范围0-n-1 的n 个数字中有且只有1个数字不再该数组中，请找出这个数字。

- 思路1： 用公式 n(n-1)/2 求出数字 0-n-1 的所有数字的和，记为s1； 接着求出数组中所有数字的和， 记为s2， 然后返回 s1 - s2 即可。
- 思路2： 从头到尾遍历数组， 遇到第一个 arr[i] != i 的， 输出i
- **思路3：** 采用二分查找，目的是找到第一个 arr[i] != i 的数。  如果 arr[mid] == mid ， 则需要向 [mid+1:]查找，如果 arr[mid] != mid ， 则先判断 arr[mid-1] == mid-1 ?, 如果不等于，则需要向 [:mid-1] 方向查找； 如果等于，则返回mid

- 测试用例：
  > - 功能测试： 缺失的值在数组开始， 中间， 末尾
  > - 边界测试： 数组中只有一个数字0
  > - 特殊输入测试： 空数组

### 3. 数组中数值和下标相等的元素 --未找到oj

- 题目： 假设一个单调递增的数组里的每个元素都是整数且唯一。 请实现一个函数，找出数组中任意一个数值等于其下标的元素。 
- 举例： [-3, -1, 1, 3, 5] ， 返回3

- 思路1： 从头到尾遍历比较，如果arr[i] == i, 则返回i 
- 思路2： 采用二分查找， 如果arr[mid] > mid， 则在 arr[:mid-1]区间内查找； 如果arr[mid] == mid， 则返回mid； 如果 arr[mid] < mid， 则在 arr[mid+1:] 内查找。

- 测试用例：
  > - 功能测试： 数组中包含或不包含数值和下标相等的元素
  > - 边界值测试： 数组中只有一个数字； 数值和下标相等的元素位于数组的开头或结尾
  > - 特殊输入： 空数组