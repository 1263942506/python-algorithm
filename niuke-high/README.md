
## 第一章

### 1.  回文数

- 来源： leetcode 9
- 题目： 给定一个整数，判断该数是否为回文数？

- 思路1： 先转化为字符串，然后遍历对比首尾字符， 时间复杂度为O(n)，它的边界条件会很恶心

### 2.  两数之和
- 来源：**leetcode 1**
- 题目： 给定一个数组arr， 一个整数aim， 请返回哪两个位置的数可以加出aim来。
- 举例： arr = [2, 7, 11, 15], target = 9. 返回 [0, 1]

- 思路1： 先排序， 然后用两个指针（头，尾）依次遍历， 但是由于要返回下标， 因此还需要记录每个元素下标的位置。-- 最佳方法
- 思路2： 采用哈希表{num:下标}， 依次遍历数组，查看 target - nums[i] 有没有出现过

- **引申1**： 给定一个有重复数字的数组arr， 一个整数target， 返回所有两个数和为target的数
- 思路： 依旧先排序， 然后维护一个pre_left, pre_right， 来避免输出重复数组

- **引申2**： 三数之和： 给定一个包含n个整数的数组nums， 判断nums中是否存在三个元素，使得 a + b + c = 0， 找出所有满足条件且不重复的三元组。
- 要求： 答案中不包含重复的三元组
-  类似：**leetcode 15**
- 思路：先固定第一个数nums[i]， 然后判断后续的数之和能不能 == target-nums[i]。 需要注意的是为了排除重复三元组，需要维护pre_num, pre_left, pre_right 三个数据。


### 3.  链表调整

给定一个链表list，
如果：
list = 1 调整之后1。
list = 1->2 调整之后1->2
list = 1->2->3 调整之后1->2->3
list = 1->2->3->4 调整之后1->3->2->4
list = 1->2->3->4->5 调整之后1->3->2->4->5
list = 1->2->3->4->5->6 调整之后1->4->2->5->3->6
list = 1->2->3->4->5->6->7 调整之后1->4->2->5->3->6->7
根据上面的规律，调整一个任意长度的链表。

- 思路1： 先将链表转化为数组，然后调整，最后再重新连接成链表。 调整的规律需要探索发现

### 4. 二叉树->有序链表



### 5. 

- 题目： **给定数组arr和整数num，共返回有多少个子数组满足如下情况：max(arr[i..j]) - min(arr[i..j]) <= num**

- 要求： 时间复杂度为O(n)

### 6. 单词接龙 2
- 来源： **leetcode 126**
- 题目： 给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：
> - 每次转换只能改变一个字母。
> - 转换过程中的中间单词必须是字典中的单词。

- 说明:
> - 如果不存在这样的转换序列，返回一个空列表。
> - 所有单词具有相同的长度。
> - 所有单词只由小写字母组成。
> - 字典中不存在重复的单词。
> - 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

- 举例：
```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]
```

- 思路：
  > - 第一步： 采用一个hashmap来存储所有单词的邻居{word:[neibors]}
  > - 第二步： 采用宽度优先遍历，设置每个word 到 beginword(0) 的距离


### 7. 最近回文数

- 来源：**leetcode 564**
- 题目: 给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。“最近的”定义为两个整数差的绝对值最小。
- 说明1：n 是由字符串表示的正整数，其长度不超过18。
- 说明2：如果有多个结果，返回最小的那个。

- 思路： 找到比它大的离它最近的数， 再找到比它小的离它最近的数。
  > - 比它大： 


## 第二章

### 1. 丑数 2
- 来源：**leetcode 264**
- 题目：编写一个程序，找出第 n 个丑数。丑数就是**只包含**质因数 2, 3, 5 的正整数。假设1是第一个丑数。

- 举例： n = 10, 输出12 （1, 2, 3, 4, 5, 6, 8, 9, 10, 12)
- 思路1： 从1开始试， 判断每一个数是否为丑数
- 思路2： 第i 个丑数 = 0-i-1个丑数中某三个数 *2， *3， *5 中最小的那个得到的

### 2. 回文对

- 来源： leetcode 336
- 题目：给定一组唯一的单词， 找出所有不同 的索引对(i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。




### 4.  字母异位词分组

- 来源： leetcode 49
- 题目： 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
- 思路1： 先对每个字符串排序， 然后再进行分组， 采用hashmap来帮助存储
- 思路2： 对每个字符串查看a-z这些字符分别出现了多少次， 然后以此连接， 如"abcd" 就用"1_1_1_1_0_0_..."来表示， 然后用hashmap存储。


### 5.  矩阵中的最长递增路径

- 来源：** leetcode 329**
- 题目：给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。
```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

### 6. 路径交叉

- 来源： **leetcode 335**
- 题目： 给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北（上）移动 x[0] 米，然后向西（左）移动 x[1] 米，向南（下）移动 x[2] 米，向东（右）移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。

- 要求：编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。